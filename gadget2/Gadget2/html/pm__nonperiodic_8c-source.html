<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>GADGET-2: pm_nonperiodic.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>pm_nonperiodic.c</h1><a href="pm__nonperiodic_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00002 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00003 <span class="preprocessor">#include &lt;string.h&gt;</span>
00004 <span class="preprocessor">#include &lt;math.h&gt;</span>
00005 <span class="preprocessor">#include &lt;mpi.h&gt;</span>
00006 
00007 
00013 <span class="preprocessor">#ifdef PMGRID</span>
00014 <span class="preprocessor"></span><span class="preprocessor">#if !defined (PERIODIC) || defined (PLACEHIGHRESREGION)</span>
00015 <span class="preprocessor"></span>
00016 <span class="preprocessor">#ifdef NOTYPEPREFIX_FFTW</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#include        &lt;rfftw_mpi.h&gt;</span>
00018 <span class="preprocessor">#else</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#ifdef DOUBLEPRECISION_FFTW</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#include     &lt;drfftw_mpi.h&gt;</span>     <span class="comment">/* double precision FFTW */</span>
00021 <span class="preprocessor">#else</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#include     &lt;srfftw_mpi.h&gt;</span>
00023 <span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00025 <span class="preprocessor"></span>
00026 <span class="preprocessor">#include "<a class="code" href="allvars_8h.html">allvars.h</a>"</span>
00027 <span class="preprocessor">#include "<a class="code" href="proto_8h.html">proto.h</a>"</span>
00028 
00029 <span class="preprocessor">#define  GRID  (2*PMGRID)</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#define  GRID2 (2*(GRID/2 + 1))</span>
00031 <span class="preprocessor"></span>
00032 
00033 
00034 <span class="keyword">static</span> rfftwnd_mpi_plan fft_forward_plan, fft_inverse_plan;
00035 
00036 <span class="keyword">static</span> <span class="keywordtype">int</span> slab_to_task[GRID];
00037 <span class="keyword">static</span> <span class="keywordtype">int</span> *slabs_per_task;
00038 <span class="keyword">static</span> <span class="keywordtype">int</span> *first_slab_of_task;
00039 
00040 <span class="keyword">static</span> <span class="keywordtype">int</span> *meshmin_list, *meshmax_list;
00041 
00042 <span class="keyword">static</span> <span class="keywordtype">int</span> slabstart_x, nslab_x, slabstart_y, nslab_y;
00043 
00044 <span class="keyword">static</span> <span class="keywordtype">int</span> fftsize, maxfftsize;
00045 
00046 <span class="keyword">static</span> fftw_real *kernel[2], *rhogrid, *forcegrid, *workspace;
00047 <span class="keyword">static</span> fftw_complex *fft_of_kernel[2], *fft_of_rhogrid;
00048 
00058 <span class="keywordtype">void</span> <a class="code" href="proto_8h.html#a127">pm_init_regionsize</a>(<span class="keywordtype">void</span>)
00059 {
00060   <span class="keywordtype">double</span> meshinner[2], xmin[2][3], xmax[2][3];
00061   <span class="keywordtype">int</span> i, j, t;
00062 
00063   <span class="comment">/* find enclosing rectangle */</span>
00064 
00065   <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
00066     {
00067       xmin[0][j] = xmin[1][j] = 1.0e36;
00068       xmax[0][j] = xmax[1][j] = -1.0e36;
00069     }
00070 
00071   <span class="keywordflow">for</span>(i = 0; i &lt; NumPart; i++)
00072     <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
00073       {
00074         t = 0;
00075 <span class="preprocessor">#ifdef PLACEHIGHRESREGION</span>
00076 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(((1 &lt;&lt; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o9">Type</a>) &amp; (PLACEHIGHRESREGION)))
00077           t = 1;
00078 <span class="preprocessor">#endif</span>
00079 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[j] &gt; xmax[t][j])
00080           xmax[t][j] = <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[j];
00081         <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[j] &lt; xmin[t][j])
00082           xmin[t][j] = <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[j];
00083       }
00084 
00085   MPI_Allreduce(xmin, <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>, 6, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
00086   MPI_Allreduce(xmax, <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o68">Xmaxtot</a>, 6, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
00087 
00088   <span class="keywordflow">for</span>(j = 0; j &lt; 2; j++)
00089     {
00090       <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[j] = <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o68">Xmaxtot</a>[j][0] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[j][0];
00091       <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[j] = <a class="code" href="system_8c.html#a4">dmax</a>(<a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[j], <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o68">Xmaxtot</a>[j][1] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[j][1]);
00092       <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[j] = <a class="code" href="system_8c.html#a4">dmax</a>(<a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[j], <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o68">Xmaxtot</a>[j][2] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[j][2]);
00093 <span class="preprocessor">#ifdef ENLARGEREGION</span>
00094 <span class="preprocessor"></span>      <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[j] *= ENLARGEREGION;
00095 <span class="preprocessor">#endif</span>
00096 <span class="preprocessor"></span>
00097       <span class="comment">/* symmetrize the box onto the center */</span>
00098       <span class="keywordflow">for</span>(i = 0; i &lt; 3; i++)
00099         {
00100           <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[j][i] = (<a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[j][i] + <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o68">Xmaxtot</a>[j][i]) / 2 - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[j] / 2;
00101           <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o68">Xmaxtot</a>[j][i] = <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[j][i] + <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[j];
00102         }
00103     }
00104 
00105   <span class="comment">/* this will produce enough room for zero-padding and buffer region to</span>
00106 <span class="comment">     allow finite differencing of the potential  */</span>
00107 
00108   <span class="keywordflow">for</span>(j = 0; j &lt; 2; j++)
00109     {
00110       meshinner[j] = <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[j];
00111       <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[j] *= 2.001 * (GRID) / ((double) (GRID - 2 - 8));
00112     }
00113 
00114   <span class="comment">/* move lower left corner by two cells to allow finite differencing of the potential by a 4-point function */</span>
00115 
00116   <span class="keywordflow">for</span>(j = 0; j &lt; 2; j++)
00117     <span class="keywordflow">for</span>(i = 0; i &lt; 3; i++)
00118       {
00119         <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[j][i] = <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[j][i] - 2.0005 * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[j] / GRID;
00120         <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[j][i] = <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[j][i] + (GRID / 2 - 1) * (<a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[j] / GRID);
00121       }
00122 
00123 
00124 <span class="preprocessor">#ifndef PERIODIC</span>
00125 <span class="preprocessor"></span>  <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o63">Asmth</a>[0] = <a class="code" href="allvars_8h.html#a29">ASMTH</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[0] / GRID;
00126   <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o64">Rcut</a>[0] = <a class="code" href="allvars_8h.html#a30">RCUT</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o63">Asmth</a>[0];
00127 <span class="preprocessor">#endif</span>
00128 <span class="preprocessor"></span>
00129 <span class="preprocessor">#ifdef PLACEHIGHRESREGION</span>
00130 <span class="preprocessor"></span>  <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o63">Asmth</a>[1] = <a class="code" href="allvars_8h.html#a29">ASMTH</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[1] / GRID;
00131   <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o64">Rcut</a>[1] = <a class="code" href="allvars_8h.html#a30">RCUT</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o63">Asmth</a>[1];
00132 <span class="preprocessor">#endif</span>
00133 <span class="preprocessor"></span>
00134 <span class="preprocessor">#ifdef PLACEHIGHRESREGION</span>
00135 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(2 * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[1] / GRID &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o64">Rcut</a>[0])
00136     {
00137       <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[1] = 2 * (meshinner[1] + 2 * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o64">Rcut</a>[0]) * (GRID) / ((double) (GRID - 2));
00138 
00139       <span class="keywordflow">for</span>(i = 0; i &lt; 3; i++)
00140         {
00141           <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[1][i] = <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[1][i] - 1.0001 * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o64">Rcut</a>[0];
00142           <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[1][i] = <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[1][i] + (GRID / 2 - 1) * (<a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[1] / GRID);
00143         }
00144 
00145       <span class="keywordflow">if</span>(2 * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[1] / GRID &gt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o64">Rcut</a>[0])
00146         {
00147           <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[1] = 2 * (meshinner[1] + 2 * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o64">Rcut</a>[0]) * (GRID) / ((double) (GRID - 10));
00148 
00149           <span class="keywordflow">for</span>(i = 0; i &lt; 3; i++)
00150             {
00151               <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[1][i] = <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[1][i] - 1.0001 * (<a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o64">Rcut</a>[0] + 2 * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[j] / GRID);
00152               <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[1][i] = <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[1][i] + (GRID / 2 - 1) * (<a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[1] / GRID);
00153             }
00154         }
00155 
00156       <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o63">Asmth</a>[1] = <a class="code" href="allvars_8h.html#a29">ASMTH</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[1] / GRID;
00157       <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o64">Rcut</a>[1] = <a class="code" href="allvars_8h.html#a30">RCUT</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o63">Asmth</a>[1];
00158     }
00159 <span class="preprocessor">#endif</span>
00160 <span class="preprocessor"></span>
00161   <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
00162     {
00163 <span class="preprocessor">#ifndef PERIODIC</span>
00164 <span class="preprocessor"></span>      printf(<span class="stringliteral">"\nAllowed region for isolated PM mesh (coarse):\n"</span>);
00165       printf(<span class="stringliteral">"(%g|%g|%g)  -&gt; (%g|%g|%g)   ext=%g  totmeshsize=%g  meshsize=%g\n\n"</span>,
00166              <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[0][0], <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[0][1], <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[0][2],
00167              <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o68">Xmaxtot</a>[0][0], <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o68">Xmaxtot</a>[0][1], <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o68">Xmaxtot</a>[0][2], meshinner[0], <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[0],
00168              <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[0] / GRID);
00169 <span class="preprocessor">#endif</span>
00170 <span class="preprocessor"></span><span class="preprocessor">#ifdef PLACEHIGHRESREGION</span>
00171 <span class="preprocessor"></span>      printf(<span class="stringliteral">"\nAllowed region for isolated PM mesh (high-res):\n"</span>);
00172       printf(<span class="stringliteral">"(%g|%g|%g)  -&gt; (%g|%g|%g)   ext=%g  totmeshsize=%g  meshsize=%g\n\n"</span>,
00173              <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[1][0], <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[1][1], <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[1][2],
00174              <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o68">Xmaxtot</a>[1][0], <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o68">Xmaxtot</a>[1][1], <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o68">Xmaxtot</a>[1][2],
00175              meshinner[1], <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[1], <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[1] / GRID);
00176 <span class="preprocessor">#endif</span>
00177 <span class="preprocessor"></span>    }
00178 
00179 }
00180 
00185 <span class="keywordtype">void</span> <a class="code" href="proto_8h.html#a121">pm_init_nonperiodic</a>(<span class="keywordtype">void</span>)
00186 {
00187   <span class="keywordtype">int</span> i, slab_to_task_local[GRID];
00188   <span class="keywordtype">double</span> bytes_tot = 0;
00189   size_t bytes;
00190 
00191   <span class="comment">/* Set up the FFTW plan files. */</span>
00192 
00193   fft_forward_plan = rfftw3d_mpi_create_plan(MPI_COMM_WORLD, GRID, GRID, GRID,
00194                                              FFTW_REAL_TO_COMPLEX, FFTW_ESTIMATE | FFTW_IN_PLACE);
00195   fft_inverse_plan = rfftw3d_mpi_create_plan(MPI_COMM_WORLD, GRID, GRID, GRID,
00196                                              FFTW_COMPLEX_TO_REAL, FFTW_ESTIMATE | FFTW_IN_PLACE);
00197 
00198   <span class="comment">/* Workspace out the ranges on each processor. */</span>
00199 
00200   rfftwnd_mpi_local_sizes(fft_forward_plan, &amp;nslab_x, &amp;slabstart_x, &amp;nslab_y, &amp;slabstart_y, &amp;fftsize);
00201 
00202 
00203   <span class="keywordflow">for</span>(i = 0; i &lt; GRID; i++)
00204     slab_to_task_local[i] = 0;
00205 
00206   <span class="keywordflow">for</span>(i = 0; i &lt; nslab_x; i++)
00207     slab_to_task_local[slabstart_x + i] = ThisTask;
00208 
00209   MPI_Allreduce(slab_to_task_local, slab_to_task, GRID, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
00210 
00211   slabs_per_task = malloc(NTask * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00212   MPI_Allgather(&amp;nslab_x, 1, MPI_INT, slabs_per_task, 1, MPI_INT, MPI_COMM_WORLD);
00213 
00214 <span class="preprocessor">#ifndef PERIODIC</span>
00215 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
00216     {
00217       <span class="keywordflow">for</span>(i = 0; i &lt; NTask; i++)
00218         printf(<span class="stringliteral">"Task=%d  FFT-Slabs=%d\n"</span>, i, slabs_per_task[i]);
00219     }
00220 <span class="preprocessor">#endif</span>
00221 <span class="preprocessor"></span>
00222   first_slab_of_task = malloc(NTask * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00223   MPI_Allgather(&amp;slabstart_x, 1, MPI_INT, first_slab_of_task, 1, MPI_INT, MPI_COMM_WORLD);
00224 
00225   meshmin_list = malloc(3 * NTask * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00226   meshmax_list = malloc(3 * NTask * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00227 
00228   MPI_Allreduce(&amp;fftsize, &amp;maxfftsize, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);
00229 
00230   <span class="comment">/* now allocate memory to hold the FFT fields */</span>
00231 
00232 <span class="preprocessor">#if !defined(PERIODIC)</span>
00233 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(!(kernel[0] = (fftw_real *) malloc(bytes = fftsize * <span class="keyword">sizeof</span>(fftw_real))))
00234     {
00235       printf(<span class="stringliteral">"failed to allocate memory for `FFT-kernel[0]' (%g MB).\n"</span>, bytes / (1024.0 * 1024.0));
00236       <a class="code" href="proto_8h.html#a38">endrun</a>(1);
00237     }
00238   bytes_tot += bytes;
00239   fft_of_kernel[0] = (fftw_complex *) kernel[0];
00240 <span class="preprocessor">#endif</span>
00241 <span class="preprocessor"></span>
00242 <span class="preprocessor">#if defined(PLACEHIGHRESREGION)</span>
00243 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(!(kernel[1] = (fftw_real *) malloc(bytes = fftsize * <span class="keyword">sizeof</span>(fftw_real))))
00244     {
00245       printf(<span class="stringliteral">"failed to allocate memory for `FFT-kernel[1]' (%g MB).\n"</span>, bytes / (1024.0 * 1024.0));
00246       <a class="code" href="proto_8h.html#a38">endrun</a>(1);
00247     }
00248   bytes_tot += bytes;
00249   fft_of_kernel[1] = (fftw_complex *) kernel[1];
00250 <span class="preprocessor">#endif</span>
00251 <span class="preprocessor"></span>
00252   <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
00253     printf(<span class="stringliteral">"\nAllocated %g MByte for FFT kernel(s).\n\n"</span>, bytes_tot / (1024.0 * 1024.0));
00254 
00255 }
00256 
00257 
00264 <span class="keywordtype">void</span> <a class="code" href="proto_8h.html#a122">pm_init_nonperiodic_allocate</a>(<span class="keywordtype">int</span> dimprod)
00265 {
00266   <span class="keyword">static</span> <span class="keywordtype">int</span> first_alloc = 1;
00267   <span class="keywordtype">int</span> dimprodmax;
00268   <span class="keywordtype">double</span> bytes_tot = 0;
00269   size_t bytes;
00270 
00271   MPI_Allreduce(&amp;dimprod, &amp;dimprodmax, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);
00272 
00273   <span class="keywordflow">if</span>(!(rhogrid = (fftw_real *) malloc(bytes = fftsize * <span class="keyword">sizeof</span>(fftw_real))))
00274     {
00275       printf(<span class="stringliteral">"failed to allocate memory for `FFT-rhogrid' (%g MB).\n"</span>, bytes / (1024.0 * 1024.0));
00276       <a class="code" href="proto_8h.html#a38">endrun</a>(1);
00277     }
00278   bytes_tot += bytes;
00279 
00280   fft_of_rhogrid = (fftw_complex *) rhogrid;
00281 
00282   <span class="keywordflow">if</span>(!(forcegrid = (fftw_real *) malloc(bytes = <a class="code" href="system_8c.html#a6">imax</a>(fftsize, dimprodmax) * <span class="keyword">sizeof</span>(fftw_real))))
00283     {
00284       printf(<span class="stringliteral">"failed to allocate memory for `FFT-forcegrid' (%g MB).\n"</span>, bytes / (1024.0 * 1024.0));
00285       <a class="code" href="proto_8h.html#a38">endrun</a>(1);
00286     }
00287   bytes_tot += bytes;
00288 
00289   <span class="keywordflow">if</span>(!(workspace = (fftw_real *) malloc(bytes = <a class="code" href="system_8c.html#a6">imax</a>(maxfftsize, dimprodmax) * <span class="keyword">sizeof</span>(fftw_real))))
00290     {
00291       printf(<span class="stringliteral">"failed to allocate memory for `FFT-workspace' (%g MB).\n"</span>, bytes / (1024.0 * 1024.0));
00292       <a class="code" href="proto_8h.html#a38">endrun</a>(1);
00293     }
00294   bytes_tot += bytes;
00295 
00296   <span class="keywordflow">if</span>(first_alloc == 1)
00297     {
00298       first_alloc = 0;
00299       <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
00300         printf(<span class="stringliteral">"\nUsing %g MByte for non-periodic FFT computation.\n\n"</span>, bytes_tot / (1024.0 * 1024.0));
00301     }
00302 }
00303 
00304 
00309 <span class="keywordtype">void</span> <a class="code" href="proto_8h.html#a123">pm_init_nonperiodic_free</a>(<span class="keywordtype">void</span>)
00310 {
00311   <span class="comment">/* deallocate memory */</span>
00312   free(workspace);
00313   free(forcegrid);
00314   free(rhogrid);
00315 }
00316 
00317 
00321 <span class="keywordtype">void</span> <a class="code" href="proto_8h.html#a128">pm_setup_nonperiodic_kernel</a>(<span class="keywordtype">void</span>)
00322 {
00323   <span class="keywordtype">int</span> i, j, k;
00324   <span class="keywordtype">double</span> x, y, z, r, u, fac;
00325   <span class="keywordtype">double</span> kx, ky, kz, k2, fx, fy, fz, ff;
00326   <span class="keywordtype">int</span> ip;
00327 
00328   <span class="comment">/* now set up kernel and its Fourier transform */</span>
00329 
00330   <a class="code" href="proto_8h.html#a122">pm_init_nonperiodic_allocate</a>(0);
00331 
00332 <span class="preprocessor">#if !defined(PERIODIC)</span>
00333 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i = 0; i &lt; fftsize; i++)  <span class="comment">/* clear local density field */</span>
00334     kernel[0][i] = 0;
00335 
00336   <span class="keywordflow">for</span>(i = slabstart_x; i &lt; (slabstart_x + nslab_x); i++)
00337     <span class="keywordflow">for</span>(j = 0; j &lt; GRID; j++)
00338       <span class="keywordflow">for</span>(k = 0; k &lt; GRID; k++)
00339         {
00340           x = ((double) i) / GRID;
00341           y = ((double) j) / GRID;
00342           z = ((double) k) / GRID;
00343 
00344           <span class="keywordflow">if</span>(x &gt;= 0.5)
00345             x -= 1.0;
00346           <span class="keywordflow">if</span>(y &gt;= 0.5)
00347             y -= 1.0;
00348           <span class="keywordflow">if</span>(z &gt;= 0.5)
00349             z -= 1.0;
00350 
00351           r = sqrt(x * x + y * y + z * z);
00352 
00353           u = 0.5 * r / (((double) ASMTH) / GRID);
00354 
00355           fac = 1 - erfc(u);
00356 
00357           <span class="keywordflow">if</span>(r &gt; 0)
00358             kernel[0][GRID * GRID2 * (i - slabstart_x) + GRID2 * j + k] = -fac / r;
00359           <span class="keywordflow">else</span>
00360             kernel[0][GRID * GRID2 * (i - slabstart_x) + GRID2 * j + k] =
00361               -1 / (sqrt(M_PI) * (((double) ASMTH) / GRID));
00362         }
00363 
00364   <span class="comment">/* do the forward transform of the kernel */</span>
00365 
00366   rfftwnd_mpi(fft_forward_plan, 1, kernel[0], workspace, FFTW_TRANSPOSED_ORDER);
00367 <span class="preprocessor">#endif</span>
00368 <span class="preprocessor"></span>
00369 
00370 <span class="preprocessor">#if defined(PLACEHIGHRESREGION)</span>
00371 <span class="preprocessor"></span>  <span class="keywordflow">for</span>(i = 0; i &lt; fftsize; i++)  <span class="comment">/* clear local density field */</span>
00372     kernel[1][i] = 0;
00373 
00374   <span class="keywordflow">for</span>(i = slabstart_x; i &lt; (slabstart_x + nslab_x); i++)
00375     <span class="keywordflow">for</span>(j = 0; j &lt; GRID; j++)
00376       <span class="keywordflow">for</span>(k = 0; k &lt; GRID; k++)
00377         {
00378           x = ((double) i) / GRID;
00379           y = ((double) j) / GRID;
00380           z = ((double) k) / GRID;
00381 
00382           <span class="keywordflow">if</span>(x &gt;= 0.5)
00383             x -= 1.0;
00384           <span class="keywordflow">if</span>(y &gt;= 0.5)
00385             y -= 1.0;
00386           <span class="keywordflow">if</span>(z &gt;= 0.5)
00387             z -= 1.0;
00388 
00389           r = sqrt(x * x + y * y + z * z);
00390 
00391           u = 0.5 * r / (((double) ASMTH) / GRID);
00392 
00393           fac = erfc(u * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o63">Asmth</a>[1] / <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o63">Asmth</a>[0]) - erfc(u);
00394 
00395           <span class="keywordflow">if</span>(r &gt; 0)
00396             kernel[1][GRID * GRID2 * (i - slabstart_x) + GRID2 * j + k] = -fac / r;
00397           <span class="keywordflow">else</span>
00398             {
00399               fac = 1 - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o63">Asmth</a>[1] / <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o63">Asmth</a>[0];
00400               kernel[1][GRID * GRID2 * (i - slabstart_x) + GRID2 * j + k] =
00401                 -fac / (sqrt(M_PI) * (((double) ASMTH) / GRID));
00402             }
00403         }
00404 
00405   <span class="comment">/* do the forward transform of the kernel */</span>
00406 
00407   rfftwnd_mpi(fft_forward_plan, 1, kernel[1], workspace, FFTW_TRANSPOSED_ORDER);
00408 <span class="preprocessor">#endif</span>
00409 <span class="preprocessor"></span>
00410   <span class="comment">/* deconvolve the Greens function twice with the CIC kernel */</span>
00411 
00412   <span class="keywordflow">for</span>(y = slabstart_y; y &lt; slabstart_y + nslab_y; y++)
00413     <span class="keywordflow">for</span>(x = 0; x &lt; GRID; x++)
00414       <span class="keywordflow">for</span>(z = 0; z &lt; GRID / 2 + 1; z++)
00415         {
00416           <span class="keywordflow">if</span>(x &gt; GRID / 2)
00417             kx = x - GRID;
00418           <span class="keywordflow">else</span>
00419             kx = x;
00420           <span class="keywordflow">if</span>(y &gt; GRID / 2)
00421             ky = y - GRID;
00422           <span class="keywordflow">else</span>
00423             ky = y;
00424           <span class="keywordflow">if</span>(z &gt; GRID / 2)
00425             kz = z - GRID;
00426           <span class="keywordflow">else</span>
00427             kz = z;
00428 
00429           k2 = kx * kx + ky * ky + kz * kz;
00430 
00431           <span class="keywordflow">if</span>(k2 &gt; 0)
00432             {
00433               fx = fy = fz = 1;
00434               <span class="keywordflow">if</span>(kx != 0)
00435                 {
00436                   fx = (M_PI * kx) / GRID;
00437                   fx = sin(fx) / fx;
00438                 }
00439               <span class="keywordflow">if</span>(ky != 0)
00440                 {
00441                   fy = (M_PI * ky) / GRID;
00442                   fy = sin(fy) / fy;
00443                 }
00444               <span class="keywordflow">if</span>(kz != 0)
00445                 {
00446                   fz = (M_PI * kz) / GRID;
00447                   fz = sin(fz) / fz;
00448                 }
00449               ff = 1 / (fx * fy * fz);
00450               ff = ff * ff * ff * ff;
00451 
00452               ip = GRID * (GRID / 2 + 1) * (y - slabstart_y) + (GRID / 2 + 1) * x + z;
00453 <span class="preprocessor">#if !defined(PERIODIC)</span>
00454 <span class="preprocessor"></span>              fft_of_kernel[0][ip].re *= ff;
00455               fft_of_kernel[0][ip].im *= ff;
00456 <span class="preprocessor">#endif</span>
00457 <span class="preprocessor"></span><span class="preprocessor">#if defined(PLACEHIGHRESREGION)</span>
00458 <span class="preprocessor"></span>              fft_of_kernel[1][ip].re *= ff;
00459               fft_of_kernel[1][ip].im *= ff;
00460 <span class="preprocessor">#endif</span>
00461 <span class="preprocessor"></span>            }
00462         }
00463   <span class="comment">/* end deconvolution */</span>
00464 
00465   <a class="code" href="proto_8h.html#a123">pm_init_nonperiodic_free</a>();
00466 }
00467 
00468 
00469 
00477 <span class="keywordtype">int</span> <a class="code" href="proto_8h.html#a129">pmforce_nonperiodic</a>(<span class="keywordtype">int</span> grnr)
00478 {
00479   <span class="keywordtype">double</span> dx, dy, dz;
00480   <span class="keywordtype">double</span> fac, to_slab_fac;
00481   <span class="keywordtype">double</span> re, im, acc_dim;
00482   <span class="keywordtype">int</span> i, j, slab, level, sendTask, recvTask, flag, flagsum;
00483   <span class="keywordtype">int</span> x, y, z, xl, yl, zl, xr, yr, zr, xll, yll, zll, xrr, yrr, zrr, ip, dim;
00484   <span class="keywordtype">int</span> slab_x, slab_y, slab_z;
00485   <span class="keywordtype">int</span> slab_xx, slab_yy, slab_zz;
00486   <span class="keywordtype">int</span> meshmin[3], meshmax[3], sendmin, sendmax, recvmin, recvmax;
00487   <span class="keywordtype">int</span> dimx, dimy, dimz, recv_dimx, recv_dimy, recv_dimz;
00488   MPI_Status status;
00489 
00490   <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
00491     printf(<span class="stringliteral">"Starting non-periodic PM calculation (grid=%d).\n"</span>, grnr);
00492 
00493   fac = <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o24">G</a> / <a class="code" href="proto_8h.html#a133">pow</a>(<a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[grnr], 4) * <a class="code" href="proto_8h.html#a133">pow</a>(<a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[grnr] / GRID, 3);       <span class="comment">/* to get potential */</span>
00494   fac *= 1 / (2 * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[grnr] / GRID);      <span class="comment">/* for finite differencing */</span>
00495 
00496   to_slab_fac = GRID / <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[grnr];
00497 
00498 
00499   <span class="comment">/* first, establish the extension of the local patch in GRID (for binning) */</span>
00500 
00501   <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
00502     {
00503       meshmin[j] = GRID;
00504       meshmax[j] = 0;
00505     }
00506 
00507   <span class="keywordflow">for</span>(i = 0, flag = 0; i &lt; NumPart; i++)
00508     {
00509 <span class="preprocessor">#ifdef PLACEHIGHRESREGION</span>
00510 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(grnr == 0 || (grnr == 1 &amp;&amp; ((1 &lt;&lt; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o9">Type</a>) &amp; (PLACEHIGHRESREGION))))
00511 <span class="preprocessor">#endif</span>
00512 <span class="preprocessor"></span>        {
00513           <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
00514             {
00515               <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[j] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[grnr][j] || <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[j] &gt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o68">Xmaxtot</a>[grnr][j])
00516                 {
00517                   <span class="keywordflow">if</span>(flag == 0)
00518                     {
00519                       printf
00520                         (<span class="stringliteral">"Particle Id=%d on task=%d with coordinates (%g|%g|%g) lies outside PM mesh.\nStopping\n"</span>,
00521                          (int)<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o8">ID</a>, ThisTask, <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0], <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1], <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2]);
00522                       fflush(stdout);
00523                     }
00524                   flag++;
00525                   <span class="keywordflow">break</span>;
00526                 }
00527             }
00528         }
00529 
00530       <span class="keywordflow">if</span>(flag &gt; 0)
00531         <span class="keywordflow">continue</span>;
00532 
00533       <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][0] &amp;&amp; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][0])
00534         <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][1] &amp;&amp; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][1])
00535           <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][2] &amp;&amp; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][2])
00536             {
00537               <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
00538                 {
00539                   slab = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[j] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][j]);
00540 
00541                   <span class="keywordflow">if</span>(slab &lt; meshmin[j])
00542                     meshmin[j] = slab;
00543 
00544                   <span class="keywordflow">if</span>(slab &gt; meshmax[j])
00545                     meshmax[j] = slab;
00546                 }
00547             }
00548     }
00549 
00550 
00551   MPI_Allreduce(&amp;flag, &amp;flagsum, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
00552   <span class="keywordflow">if</span>(flagsum &gt; 0)
00553     {
00554       <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
00555         {
00556           printf(<span class="stringliteral">"In total %d particles were outside allowed range.\n"</span>, flagsum);
00557           fflush(stdout);
00558         }
00559       <span class="keywordflow">return</span> 1;                 <span class="comment">/* error - need to return because particle were outside allowed range */</span>
00560     }
00561 
00562   MPI_Allgather(meshmin, 3, MPI_INT, meshmin_list, 3, MPI_INT, MPI_COMM_WORLD);
00563   MPI_Allgather(meshmax, 3, MPI_INT, meshmax_list, 3, MPI_INT, MPI_COMM_WORLD);
00564 
00565   dimx = meshmax[0] - meshmin[0] + 2;
00566   dimy = meshmax[1] - meshmin[1] + 2;
00567   dimz = meshmax[2] - meshmin[2] + 2;
00568 
00569 
00570   <a class="code" href="forcetree_8c.html#a34">force_treefree</a>();
00571 
00572   <a class="code" href="proto_8h.html#a122">pm_init_nonperiodic_allocate</a>((dimx + 4) * (dimy + 4) * (dimz + 4));
00573 
00574   <span class="keywordflow">for</span>(i = 0; i &lt; dimx * dimy * dimz; i++)
00575     workspace[i] = 0;
00576 
00577   <span class="keywordflow">for</span>(i = 0; i &lt; NumPart; i++)
00578     {
00579       <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][0] || <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][0])
00580         <span class="keywordflow">continue</span>;
00581       <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][1] || <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][1])
00582         <span class="keywordflow">continue</span>;
00583       <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][2] || <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][2])
00584         <span class="keywordflow">continue</span>;
00585 
00586       slab_x = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][0]);
00587       dx = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][0]) - slab_x;
00588       slab_x -= meshmin[0];
00589       slab_xx = slab_x + 1;
00590 
00591       slab_y = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][1]);
00592       dy = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][1]) - slab_y;
00593       slab_y -= meshmin[1];
00594       slab_yy = slab_y + 1;
00595 
00596       slab_z = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][2]);
00597       dz = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][2]) - slab_z;
00598       slab_z -= meshmin[2];
00599       slab_zz = slab_z + 1;
00600 
00601       workspace[(slab_x * dimy + slab_y) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * (1.0 - dy) * (1.0 - dz);
00602       workspace[(slab_x * dimy + slab_yy) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * dy * (1.0 - dz);
00603       workspace[(slab_x * dimy + slab_y) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * (1.0 - dy) * dz;
00604       workspace[(slab_x * dimy + slab_yy) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * dy * dz;
00605 
00606       workspace[(slab_xx * dimy + slab_y) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * (1.0 - dy) * (1.0 - dz);
00607       workspace[(slab_xx * dimy + slab_yy) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * dy * (1.0 - dz);
00608       workspace[(slab_xx * dimy + slab_y) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * (1.0 - dy) * dz;
00609       workspace[(slab_xx * dimy + slab_yy) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * dy * dz;
00610     }
00611 
00612 
00613   <span class="keywordflow">for</span>(i = 0; i &lt; fftsize; i++)  <span class="comment">/* clear local density field */</span>
00614     rhogrid[i] = 0;
00615 
00616   <span class="keywordflow">for</span>(level = 0; level &lt; (1 &lt;&lt; PTask); level++) <span class="comment">/* note: for level=0, target is the same task */</span>
00617     {
00618       sendTask = ThisTask;
00619       recvTask = <a class="code" href="allvars_8c.html#a0">ThisTask</a> ^ level;
00620       <span class="keywordflow">if</span>(recvTask &lt; NTask)
00621         {
00622           <span class="comment">/* check how much we have to send */</span>
00623           sendmin = 2 * GRID;
00624           sendmax = -1;
00625           <span class="keywordflow">for</span>(slab_x = meshmin[0]; slab_x &lt; meshmax[0] + 2; slab_x++)
00626             <span class="keywordflow">if</span>(slab_to_task[slab_x] == recvTask)
00627               {
00628                 <span class="keywordflow">if</span>(slab_x &lt; sendmin)
00629                   sendmin = slab_x;
00630                 <span class="keywordflow">if</span>(slab_x &gt; sendmax)
00631                   sendmax = slab_x;
00632               }
00633           <span class="keywordflow">if</span>(sendmax == -1)
00634             sendmin = 0;
00635 
00636           <span class="comment">/* check how much we have to receive */</span>
00637           recvmin = 2 * GRID;
00638           recvmax = -1;
00639           <span class="keywordflow">for</span>(slab_x = meshmin_list[3 * recvTask]; slab_x &lt; meshmax_list[3 * recvTask] + 2; slab_x++)
00640             <span class="keywordflow">if</span>(slab_to_task[slab_x] == sendTask)
00641               {
00642                 <span class="keywordflow">if</span>(slab_x &lt; recvmin)
00643                   recvmin = slab_x;
00644                 <span class="keywordflow">if</span>(slab_x &gt; recvmax)
00645                   recvmax = slab_x;
00646               }
00647           <span class="keywordflow">if</span>(recvmax == -1)
00648             recvmin = 0;
00649 
00650           <span class="keywordflow">if</span>((recvmax - recvmin) &gt;= 0 || (sendmax - sendmin) &gt;= 0)      <span class="comment">/* ok, we have a contribution to the slab */</span>
00651             {
00652               recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * recvTask + 0] + 2;
00653               recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * recvTask + 1] + 2;
00654               recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * recvTask + 2] + 2;
00655 
00656               <span class="keywordflow">if</span>(level &gt; 0)
00657                 {
00658                   MPI_Sendrecv(workspace + (sendmin - meshmin[0]) * dimy * dimz,
00659                                (sendmax - sendmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real), MPI_BYTE, recvTask,
00660                                TAG_NONPERIOD_A, forcegrid,
00661                                (recvmax - recvmin + 1) * recv_dimy * recv_dimz * <span class="keyword">sizeof</span>(fftw_real), MPI_BYTE,
00662                                recvTask, TAG_NONPERIOD_A, MPI_COMM_WORLD, &amp;status);
00663                 }
00664               <span class="keywordflow">else</span>
00665                 {
00666                   memcpy(forcegrid, workspace + (sendmin - meshmin[0]) * dimy * dimz,
00667                          (sendmax - sendmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real));
00668                 }
00669 
00670               <span class="keywordflow">for</span>(slab_x = recvmin; slab_x &lt;= recvmax; slab_x++)
00671                 {
00672                   slab_xx = slab_x - first_slab_of_task[ThisTask];
00673 
00674                   <span class="keywordflow">if</span>(slab_xx &gt;= 0 &amp;&amp; slab_xx &lt; slabs_per_task[ThisTask])
00675                     {
00676                       <span class="keywordflow">for</span>(slab_y = meshmin_list[3 * recvTask + 1];
00677                           slab_y &lt;= meshmax_list[3 * recvTask + 1] + 1; slab_y++)
00678                         {
00679                           slab_yy = slab_y;
00680 
00681                           <span class="keywordflow">for</span>(slab_z = meshmin_list[3 * recvTask + 2];
00682                               slab_z &lt;= meshmax_list[3 * recvTask + 2] + 1; slab_z++)
00683                             {
00684                               slab_zz = slab_z;
00685 
00686                               rhogrid[GRID * GRID2 * slab_xx + GRID2 * slab_yy + slab_zz] +=
00687                                 forcegrid[((slab_x - recvmin) * recv_dimy +
00688                                            (slab_y - meshmin_list[3 * recvTask + 1])) * recv_dimz +
00689                                           (slab_z - meshmin_list[3 * recvTask + 2])];
00690                             }
00691                         }
00692                     }
00693                 }
00694             }
00695         }
00696     }
00697 
00698 
00699   <span class="comment">/* Do the FFT of the density field */</span>
00700 
00701   rfftwnd_mpi(fft_forward_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);
00702 
00703 
00704   <span class="comment">/* multiply with the Fourier transform of the Green's function (kernel) */</span>
00705 
00706   <span class="keywordflow">for</span>(y = 0; y &lt; nslab_y; y++)
00707     <span class="keywordflow">for</span>(x = 0; x &lt; GRID; x++)
00708       <span class="keywordflow">for</span>(z = 0; z &lt; GRID / 2 + 1; z++)
00709         {
00710           ip = GRID * (GRID / 2 + 1) * y + (GRID / 2 + 1) * x + z;
00711 
00712           re =
00713             fft_of_rhogrid[ip].re * fft_of_kernel[grnr][ip].re -
00714             fft_of_rhogrid[ip].im * fft_of_kernel[grnr][ip].im;
00715 
00716           im =
00717             fft_of_rhogrid[ip].re * fft_of_kernel[grnr][ip].im +
00718             fft_of_rhogrid[ip].im * fft_of_kernel[grnr][ip].re;
00719 
00720           fft_of_rhogrid[ip].re = re;
00721           fft_of_rhogrid[ip].im = im;
00722         }
00723 
00724   <span class="comment">/* get the potential by inverse FFT */</span>
00725 
00726   rfftwnd_mpi(fft_inverse_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);
00727 
00728   <span class="comment">/* Now rhogrid holds the potential */</span>
00729   <span class="comment">/* construct the potential for the local patch */</span>
00730 
00731 
00732   <span class="comment">/* if we have a high-res mesh, establish the extension of the local patch in GRID (for reading out the</span>
00733 <span class="comment">   * forces) </span>
00734 <span class="comment">   */</span>
00735 
00736 <span class="preprocessor">#ifdef PLACEHIGHRESREGION</span>
00737 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(grnr == 1)
00738     {
00739       <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
00740         {
00741           meshmin[j] = GRID;
00742           meshmax[j] = 0;
00743         }
00744 
00745       <span class="keywordflow">for</span>(i = 0; i &lt; NumPart; i++)
00746         {
00747           <span class="keywordflow">if</span>(!((1 &lt;&lt; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o9">Type</a>) &amp; (PLACEHIGHRESREGION)))
00748             <span class="keywordflow">continue</span>;
00749 
00750 
00751           <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][0] &amp;&amp; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][0])
00752             <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][1] &amp;&amp; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][1])
00753               <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][2] &amp;&amp; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][2])
00754                 {
00755                   <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
00756                     {
00757                       slab = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[j] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][j]);
00758 
00759                       <span class="keywordflow">if</span>(slab &lt; meshmin[j])
00760                         meshmin[j] = slab;
00761 
00762                       <span class="keywordflow">if</span>(slab &gt; meshmax[j])
00763                         meshmax[j] = slab;
00764                     }
00765                 }
00766         }
00767 
00768       MPI_Allgather(meshmin, 3, MPI_INT, meshmin_list, 3, MPI_INT, MPI_COMM_WORLD);
00769       MPI_Allgather(meshmax, 3, MPI_INT, meshmax_list, 3, MPI_INT, MPI_COMM_WORLD);
00770     }
00771 <span class="preprocessor">#endif</span>
00772 <span class="preprocessor"></span>
00773   dimx = meshmax[0] - meshmin[0] + 6;
00774   dimy = meshmax[1] - meshmin[1] + 6;
00775   dimz = meshmax[2] - meshmin[2] + 6;
00776 
00777   <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
00778     {
00779       <span class="keywordflow">if</span>(meshmin[j] &lt; 2)
00780         <a class="code" href="proto_8h.html#a38">endrun</a>(131231);
00781       <span class="keywordflow">if</span>(meshmax[j] &gt; GRID / 2 - 3)
00782         <a class="code" href="proto_8h.html#a38">endrun</a>(131288);
00783     }
00784 
00785   <span class="keywordflow">for</span>(level = 0; level &lt; (1 &lt;&lt; PTask); level++) <span class="comment">/* note: for level=0, target is the same task */</span>
00786     {
00787       sendTask = ThisTask;
00788       recvTask = <a class="code" href="allvars_8c.html#a0">ThisTask</a> ^ level;
00789 
00790       <span class="keywordflow">if</span>(recvTask &lt; NTask)
00791         {
00792           <span class="comment">/* check how much we have to send */</span>
00793           sendmin = 2 * GRID;
00794           sendmax = -GRID;
00795           <span class="keywordflow">for</span>(slab_x = meshmin_list[3 * recvTask] - 2; slab_x &lt; meshmax_list[3 * recvTask] + 4; slab_x++)
00796             <span class="keywordflow">if</span>(slab_to_task[slab_x] == sendTask)
00797               {
00798                 <span class="keywordflow">if</span>(slab_x &lt; sendmin)
00799                   sendmin = slab_x;
00800                 <span class="keywordflow">if</span>(slab_x &gt; sendmax)
00801                   sendmax = slab_x;
00802               }
00803           <span class="keywordflow">if</span>(sendmax == -GRID)
00804             sendmin = sendmax + 1;
00805 
00806 
00807           <span class="comment">/* check how much we have to receive */</span>
00808           recvmin = 2 * GRID;
00809           recvmax = -GRID;
00810           <span class="keywordflow">for</span>(slab_x = meshmin[0] - 2; slab_x &lt; meshmax[0] + 4; slab_x++)
00811             <span class="keywordflow">if</span>(slab_to_task[slab_x] == recvTask)
00812               {
00813                 <span class="keywordflow">if</span>(slab_x &lt; recvmin)
00814                   recvmin = slab_x;
00815                 <span class="keywordflow">if</span>(slab_x &gt; recvmax)
00816                   recvmax = slab_x;
00817               }
00818           <span class="keywordflow">if</span>(recvmax == -GRID)
00819             recvmin = recvmax + 1;
00820 
00821           <span class="keywordflow">if</span>((recvmax - recvmin) &gt;= 0 || (sendmax - sendmin) &gt;= 0)      <span class="comment">/* ok, we have a contribution to the slab */</span>
00822             {
00823               recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * recvTask + 0] + 6;
00824               recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * recvTask + 1] + 6;
00825               recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * recvTask + 2] + 6;
00826 
00827               <span class="comment">/* prepare what we want to send */</span>
00828               <span class="keywordflow">if</span>(sendmax - sendmin &gt;= 0)
00829                 {
00830                   <span class="keywordflow">for</span>(slab_x = sendmin; slab_x &lt;= sendmax; slab_x++)
00831                     {
00832                       slab_xx = slab_x - first_slab_of_task[ThisTask];
00833 
00834                       <span class="keywordflow">for</span>(slab_y = meshmin_list[3 * recvTask + 1] - 2;
00835                           slab_y &lt; meshmax_list[3 * recvTask + 1] + 4; slab_y++)
00836                         {
00837                           slab_yy = slab_y;
00838 
00839                           <span class="keywordflow">for</span>(slab_z = meshmin_list[3 * recvTask + 2] - 2;
00840                               slab_z &lt; meshmax_list[3 * recvTask + 2] + 4; slab_z++)
00841                             {
00842                               slab_zz = slab_z;
00843 
00844                               forcegrid[((slab_x - sendmin) * recv_dimy +
00845                                          (slab_y - (meshmin_list[3 * recvTask + 1] - 2))) * recv_dimz +
00846                                         slab_z - (meshmin_list[3 * recvTask + 2] - 2)] =
00847                                 rhogrid[GRID * GRID2 * slab_xx + GRID2 * slab_yy + slab_zz];
00848                             }
00849                         }
00850                     }
00851                 }
00852 
00853               <span class="keywordflow">if</span>(level &gt; 0)
00854                 {
00855                   MPI_Sendrecv(forcegrid,
00856                                (sendmax - sendmin + 1) * recv_dimy * recv_dimz * <span class="keyword">sizeof</span>(fftw_real),
00857                                MPI_BYTE, recvTask, TAG_NONPERIOD_B,
00858                                workspace + (recvmin - (meshmin[0] - 2)) * dimy * dimz,
00859                                (recvmax - recvmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real), MPI_BYTE,
00860                                recvTask, TAG_NONPERIOD_B, MPI_COMM_WORLD, &amp;status);
00861                 }
00862               <span class="keywordflow">else</span>
00863                 {
00864                   memcpy(workspace + (recvmin - (meshmin[0] - 2)) * dimy * dimz,
00865                          forcegrid, (recvmax - recvmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real));
00866                 }
00867             }
00868         }
00869     }
00870 
00871   dimx = meshmax[0] - meshmin[0] + 2;
00872   dimy = meshmax[1] - meshmin[1] + 2;
00873   dimz = meshmax[2] - meshmin[2] + 2;
00874 
00875   recv_dimx = meshmax[0] - meshmin[0] + 6;
00876   recv_dimy = meshmax[1] - meshmin[1] + 6;
00877   recv_dimz = meshmax[2] - meshmin[2] + 6;
00878 
00879 
00880   <span class="keywordflow">for</span>(dim = 0; dim &lt; 3; dim++)  <span class="comment">/* Calculate each component of the force. */</span>
00881     {
00882       <span class="comment">/* get the force component by finite differencing the potential */</span>
00883       <span class="comment">/* note: "workspace" now contains the potential for the local patch, plus a suffiently large buffer region */</span>
00884 
00885       <span class="keywordflow">for</span>(x = 0; x &lt; meshmax[0] - meshmin[0] + 2; x++)
00886         <span class="keywordflow">for</span>(y = 0; y &lt; meshmax[1] - meshmin[1] + 2; y++)
00887           <span class="keywordflow">for</span>(z = 0; z &lt; meshmax[2] - meshmin[2] + 2; z++)
00888             {
00889               xrr = xll = xr = xl = x;
00890               yrr = yll = yr = yl = y;
00891               zrr = zll = zr = zl = z;
00892 
00893               <span class="keywordflow">switch</span> (dim)
00894                 {
00895                 <span class="keywordflow">case</span> 0:
00896                   xr = x + 1;
00897                   xrr = x + 2;
00898                   xl = x - 1;
00899                   xll = x - 2;
00900                   <span class="keywordflow">break</span>;
00901                 <span class="keywordflow">case</span> 1:
00902                   yr = y + 1;
00903                   yl = y - 1;
00904                   yrr = y + 2;
00905                   yll = y - 2;
00906                   <span class="keywordflow">break</span>;
00907                 <span class="keywordflow">case</span> 2:
00908                   zr = z + 1;
00909                   zl = z - 1;
00910                   zrr = z + 2;
00911                   zll = z - 2;
00912                   <span class="keywordflow">break</span>;
00913                 }
00914 
00915               forcegrid[(x * dimy + y) * dimz + z]
00916                 =
00917                 fac * ((4.0 / 3) *
00918                        (workspace[((xl + 2) * recv_dimy + (yl + 2)) * recv_dimz + (zl + 2)]
00919                         - workspace[((xr + 2) * recv_dimy + (yr + 2)) * recv_dimz + (zr + 2)]) -
00920                        (1.0 / 6) *
00921                        (workspace[((xll + 2) * recv_dimy + (yll + 2)) * recv_dimz + (zll + 2)] -
00922                         workspace[((xrr + 2) * recv_dimy + (yrr + 2)) * recv_dimz + (zrr + 2)]));
00923             }
00924 
00925 
00926       <span class="comment">/* read out the forces */</span>
00927 
00928       <span class="keywordflow">for</span>(i = 0; i &lt; NumPart; i++)
00929         {
00930 <span class="preprocessor">#ifdef PLACEHIGHRESREGION</span>
00931 <span class="preprocessor"></span>          <span class="keywordflow">if</span>(grnr == 1)
00932             <span class="keywordflow">if</span>(!((1 &lt;&lt; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o9">Type</a>) &amp; (PLACEHIGHRESREGION)))
00933               <span class="keywordflow">continue</span>;
00934 <span class="preprocessor">#endif</span>
00935 <span class="preprocessor"></span>          slab_x = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][0]);
00936           dx = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][0]) - slab_x;
00937           slab_x -= meshmin[0];
00938           slab_xx = slab_x + 1;
00939 
00940           slab_y = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][1]);
00941           dy = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][1]) - slab_y;
00942           slab_y -= meshmin[1];
00943           slab_yy = slab_y + 1;
00944 
00945           slab_z = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][2]);
00946           dz = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][2]) - slab_z;
00947           slab_z -= meshmin[2];
00948           slab_zz = slab_z + 1;
00949 
00950           acc_dim =
00951             forcegrid[(slab_x * dimy + slab_y) * dimz + slab_z] * (1.0 - dx) * (1.0 - dy) * (1.0 - dz);
00952           acc_dim += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_z] * (1.0 - dx) * dy * (1.0 - dz);
00953           acc_dim += forcegrid[(slab_x * dimy + slab_y) * dimz + slab_zz] * (1.0 - dx) * (1.0 - dy) * dz;
00954           acc_dim += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_zz] * (1.0 - dx) * dy * dz;
00955 
00956           acc_dim += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_z] * (dx) * (1.0 - dy) * (1.0 - dz);
00957           acc_dim += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_z] * (dx) * dy * (1.0 - dz);
00958           acc_dim += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_zz] * (dx) * (1.0 - dy) * dz;
00959           acc_dim += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_zz] * (dx) * dy * dz;
00960 
00961           <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o4">GravPM</a>[dim] += acc_dim;
00962         }
00963     }
00964 
00965   <a class="code" href="proto_8h.html#a123">pm_init_nonperiodic_free</a>();
00966   <a class="code" href="proto_8h.html#a57">force_treeallocate</a>(<a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o15">TreeAllocFactor</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o2">MaxPart</a>, <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o2">MaxPart</a>);
00967   <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o23">NumForcesSinceLastDomainDecomp</a> = 1 + <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o0">TotNumPart</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o96">TreeDomainUpdateFrequency</a>;
00968 
00969   <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
00970     printf(<span class="stringliteral">"done PM.\n"</span>);
00971 
00972   <span class="keywordflow">return</span> 0;
00973 }
00974 
00975 
00976 
00977 
00983 <span class="keywordtype">int</span> <a class="code" href="proto_8h.html#a131">pmpotential_nonperiodic</a>(<span class="keywordtype">int</span> grnr)
00984 {
00985   <span class="keywordtype">double</span> dx, dy, dz;
00986   <span class="keywordtype">double</span> fac, to_slab_fac;
00987   <span class="keywordtype">double</span> re, im, pot;
00988   <span class="keywordtype">int</span> i, j, slab, level, sendTask, recvTask, flag, flagsum;
00989   <span class="keywordtype">int</span> x, y, z, ip;
00990   <span class="keywordtype">int</span> slab_x, slab_y, slab_z;
00991   <span class="keywordtype">int</span> slab_xx, slab_yy, slab_zz;
00992   <span class="keywordtype">int</span> meshmin[3], meshmax[3], sendmin, sendmax, recvmin, recvmax;
00993   <span class="keywordtype">int</span> dimx, dimy, dimz, recv_dimx, recv_dimy, recv_dimz;
00994   MPI_Status status;
00995 
00996 
00997   <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
00998     printf(<span class="stringliteral">"Starting non-periodic PM-potential calculation.\n"</span>);
00999 
01000   fac = <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o24">G</a> / <a class="code" href="proto_8h.html#a133">pow</a>(<a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[grnr], 4) * <a class="code" href="proto_8h.html#a133">pow</a>(<a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[grnr] / GRID, 3);       <span class="comment">/* to get potential */</span>
01001 
01002   to_slab_fac = GRID / <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o69">TotalMeshSize</a>[grnr];
01003 
01004   <span class="comment">/* first, establish the extension of the local patch in GRID (for binning) */</span>
01005 
01006   <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
01007     {
01008       meshmin[j] = GRID;
01009       meshmax[j] = 0;
01010     }
01011 
01012   <span class="keywordflow">for</span>(i = 0, flag = 0; i &lt; NumPart; i++)
01013     {
01014 <span class="preprocessor">#ifdef PLACEHIGHRESREGION</span>
01015 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(grnr == 0 || (grnr == 1 &amp;&amp; ((1 &lt;&lt; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o9">Type</a>) &amp; (PLACEHIGHRESREGION))))
01016 <span class="preprocessor">#endif</span>
01017 <span class="preprocessor"></span>        {
01018           <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
01019             {
01020               <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[j] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o67">Xmintot</a>[grnr][j] || <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[j] &gt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o68">Xmaxtot</a>[grnr][j])
01021                 {
01022                   <span class="keywordflow">if</span>(flag == 0)
01023                     {
01024                       printf
01025                         (<span class="stringliteral">"Particle Id=%d on task=%d with coordinates (%g|%g|%g) lies outside PM mesh.\nStopping\n"</span>,
01026                          (int)<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o8">ID</a>, ThisTask, <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0], <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1], <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2]);
01027                       fflush(stdout);
01028                     }
01029                   flag++;
01030                   <span class="keywordflow">break</span>;
01031                 }
01032             }
01033         }
01034 
01035       <span class="keywordflow">if</span>(flag &gt; 0)
01036         <span class="keywordflow">continue</span>;
01037 
01038       <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][0] &amp;&amp; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][0])
01039         <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][1] &amp;&amp; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][1])
01040           <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][2] &amp;&amp; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][2])
01041             {
01042               <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
01043                 {
01044                   slab = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[j] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][j]);
01045 
01046                   <span class="keywordflow">if</span>(slab &lt; meshmin[j])
01047                     meshmin[j] = slab;
01048 
01049                   <span class="keywordflow">if</span>(slab &gt; meshmax[j])
01050                     meshmax[j] = slab;
01051                 }
01052             }
01053     }
01054 
01055 
01056   MPI_Allreduce(&amp;flag, &amp;flagsum, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
01057   <span class="keywordflow">if</span>(flagsum &gt; 0) 
01058     {
01059       <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
01060         {
01061           printf(<span class="stringliteral">"In total %d particles were outside allowed range.\n"</span>, flagsum);
01062           fflush(stdout);
01063         }
01064       <span class="keywordflow">return</span> 1;                 <span class="comment">/* error - need to return because particle were outside allowed range */</span>
01065     }
01066 
01067 
01068 
01069   MPI_Allgather(meshmin, 3, MPI_INT, meshmin_list, 3, MPI_INT, MPI_COMM_WORLD);
01070   MPI_Allgather(meshmax, 3, MPI_INT, meshmax_list, 3, MPI_INT, MPI_COMM_WORLD);
01071 
01072   dimx = meshmax[0] - meshmin[0] + 2;
01073   dimy = meshmax[1] - meshmin[1] + 2;
01074   dimz = meshmax[2] - meshmin[2] + 2;
01075 
01076 
01077   <a class="code" href="forcetree_8c.html#a34">force_treefree</a>();
01078 
01079   <a class="code" href="proto_8h.html#a122">pm_init_nonperiodic_allocate</a>((dimx + 4) * (dimy + 4) * (dimz + 4));
01080 
01081   <span class="keywordflow">for</span>(i = 0; i &lt; dimx * dimy * dimz; i++)
01082     workspace[i] = 0;
01083 
01084   <span class="keywordflow">for</span>(i = 0; i &lt; NumPart; i++)
01085     {
01086       <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][0] || <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][0])
01087         <span class="keywordflow">continue</span>;
01088       <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][1] || <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][1])
01089         <span class="keywordflow">continue</span>;
01090       <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][2] || <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][2])
01091         <span class="keywordflow">continue</span>;
01092 
01093       slab_x = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][0]);
01094       dx = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][0]) - slab_x;
01095       slab_x -= meshmin[0];
01096       slab_xx = slab_x + 1;
01097 
01098       slab_y = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][1]);
01099       dy = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][1]) - slab_y;
01100       slab_y -= meshmin[1];
01101       slab_yy = slab_y + 1;
01102 
01103       slab_z = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][2]);
01104       dz = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][2]) - slab_z;
01105       slab_z -= meshmin[2];
01106       slab_zz = slab_z + 1;
01107 
01108       workspace[(slab_x * dimy + slab_y) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * (1.0 - dy) * (1.0 - dz);
01109       workspace[(slab_x * dimy + slab_yy) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * dy * (1.0 - dz);
01110       workspace[(slab_x * dimy + slab_y) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * (1.0 - dy) * dz;
01111       workspace[(slab_x * dimy + slab_yy) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * dy * dz;
01112 
01113       workspace[(slab_xx * dimy + slab_y) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * (1.0 - dy) * (1.0 - dz);
01114       workspace[(slab_xx * dimy + slab_yy) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * dy * (1.0 - dz);
01115       workspace[(slab_xx * dimy + slab_y) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * (1.0 - dy) * dz;
01116       workspace[(slab_xx * dimy + slab_yy) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * dy * dz;
01117     }
01118 
01119 
01120   <span class="keywordflow">for</span>(i = 0; i &lt; fftsize; i++)  <span class="comment">/* clear local density field */</span>
01121     rhogrid[i] = 0;
01122 
01123   <span class="keywordflow">for</span>(level = 0; level &lt; (1 &lt;&lt; PTask); level++) <span class="comment">/* note: for level=0, target is the same task */</span>
01124     {
01125       sendTask = ThisTask;
01126       recvTask = <a class="code" href="allvars_8c.html#a0">ThisTask</a> ^ level;
01127       <span class="keywordflow">if</span>(recvTask &lt; NTask)
01128         {
01129           <span class="comment">/* check how much we have to send */</span>
01130           sendmin = 2 * GRID;
01131           sendmax = -1;
01132           <span class="keywordflow">for</span>(slab_x = meshmin[0]; slab_x &lt; meshmax[0] + 2; slab_x++)
01133             <span class="keywordflow">if</span>(slab_to_task[slab_x] == recvTask)
01134               {
01135                 <span class="keywordflow">if</span>(slab_x &lt; sendmin)
01136                   sendmin = slab_x;
01137                 <span class="keywordflow">if</span>(slab_x &gt; sendmax)
01138                   sendmax = slab_x;
01139               }
01140           <span class="keywordflow">if</span>(sendmax == -1)
01141             sendmin = 0;
01142 
01143           <span class="comment">/* check how much we have to receive */</span>
01144           recvmin = 2 * GRID;
01145           recvmax = -1;
01146           <span class="keywordflow">for</span>(slab_x = meshmin_list[3 * recvTask]; slab_x &lt; meshmax_list[3 * recvTask] + 2; slab_x++)
01147             <span class="keywordflow">if</span>(slab_to_task[slab_x] == sendTask)
01148               {
01149                 <span class="keywordflow">if</span>(slab_x &lt; recvmin)
01150                   recvmin = slab_x;
01151                 <span class="keywordflow">if</span>(slab_x &gt; recvmax)
01152                   recvmax = slab_x;
01153               }
01154           <span class="keywordflow">if</span>(recvmax == -1)
01155             recvmin = 0;
01156 
01157           <span class="keywordflow">if</span>((recvmax - recvmin) &gt;= 0 || (sendmax - sendmin) &gt;= 0)      <span class="comment">/* ok, we have a contribution to the slab */</span>
01158             {
01159               recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * recvTask + 0] + 2;
01160               recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * recvTask + 1] + 2;
01161               recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * recvTask + 2] + 2;
01162 
01163               <span class="keywordflow">if</span>(level &gt; 0)
01164                 {
01165                   MPI_Sendrecv(workspace + (sendmin - meshmin[0]) * dimy * dimz,
01166                                (sendmax - sendmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real), MPI_BYTE, recvTask,
01167                                TAG_NONPERIOD_C, forcegrid,
01168                                (recvmax - recvmin + 1) * recv_dimy * recv_dimz * <span class="keyword">sizeof</span>(fftw_real), MPI_BYTE,
01169                                recvTask, TAG_NONPERIOD_C, MPI_COMM_WORLD, &amp;status);
01170                 }
01171               <span class="keywordflow">else</span>
01172                 {
01173                   memcpy(forcegrid, workspace + (sendmin - meshmin[0]) * dimy * dimz,
01174                          (sendmax - sendmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real));
01175                 }
01176 
01177               <span class="keywordflow">for</span>(slab_x = recvmin; slab_x &lt;= recvmax; slab_x++)
01178                 {
01179                   slab_xx = slab_x - first_slab_of_task[ThisTask];
01180 
01181                   <span class="keywordflow">if</span>(slab_xx &gt;= 0 &amp;&amp; slab_xx &lt; slabs_per_task[ThisTask])
01182                     {
01183                       <span class="keywordflow">for</span>(slab_y = meshmin_list[3 * recvTask + 1];
01184                           slab_y &lt;= meshmax_list[3 * recvTask + 1] + 1; slab_y++)
01185                         {
01186                           slab_yy = slab_y;
01187 
01188                           <span class="keywordflow">for</span>(slab_z = meshmin_list[3 * recvTask + 2];
01189                               slab_z &lt;= meshmax_list[3 * recvTask + 2] + 1; slab_z++)
01190                             {
01191                               slab_zz = slab_z;
01192 
01193                               rhogrid[GRID * GRID2 * slab_xx + GRID2 * slab_yy + slab_zz] +=
01194                                 forcegrid[((slab_x - recvmin) * recv_dimy +
01195                                            (slab_y - meshmin_list[3 * recvTask + 1])) * recv_dimz +
01196                                           (slab_z - meshmin_list[3 * recvTask + 2])];
01197                             }
01198                         }
01199                     }
01200                 }
01201             }
01202         }
01203     }
01204 
01205 
01206   <span class="comment">/* Do the FFT of the density field */</span>
01207 
01208   rfftwnd_mpi(fft_forward_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);
01209 
01210 
01211   <span class="comment">/* multiply with the Fourier transform of the Green's function (kernel) */</span>
01212 
01213   <span class="keywordflow">for</span>(y = 0; y &lt; nslab_y; y++)
01214     <span class="keywordflow">for</span>(x = 0; x &lt; GRID; x++)
01215       <span class="keywordflow">for</span>(z = 0; z &lt; GRID / 2 + 1; z++)
01216         {
01217           ip = GRID * (GRID / 2 + 1) * y + (GRID / 2 + 1) * x + z;
01218 
01219           re =
01220             fft_of_rhogrid[ip].re * fft_of_kernel[grnr][ip].re -
01221             fft_of_rhogrid[ip].im * fft_of_kernel[grnr][ip].im;
01222 
01223           im =
01224             fft_of_rhogrid[ip].re * fft_of_kernel[grnr][ip].im +
01225             fft_of_rhogrid[ip].im * fft_of_kernel[grnr][ip].re;
01226 
01227           fft_of_rhogrid[ip].re = fac * re;
01228           fft_of_rhogrid[ip].im = fac * im;
01229         }
01230 
01231   <span class="comment">/* get the potential by inverse FFT */</span>
01232 
01233   rfftwnd_mpi(fft_inverse_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);
01234 
01235   <span class="comment">/* Now rhogrid holds the potential */</span>
01236   <span class="comment">/* construct the potential for the local patch */</span>
01237 
01238 
01239   <span class="comment">/* if we have a high-res mesh, establish the extension of the local patch in GRID (for reading out the</span>
01240 <span class="comment">   * forces) </span>
01241 <span class="comment">   */</span>
01242 
01243 <span class="preprocessor">#ifdef PLACEHIGHRESREGION</span>
01244 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(grnr == 1)
01245     {
01246       <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
01247         {
01248           meshmin[j] = GRID;
01249           meshmax[j] = 0;
01250         }
01251 
01252       <span class="keywordflow">for</span>(i = 0; i &lt; NumPart; i++)
01253         {
01254           <span class="keywordflow">if</span>(!((1 &lt;&lt; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o9">Type</a>) &amp; (PLACEHIGHRESREGION)))
01255             <span class="keywordflow">continue</span>;
01256 
01257 
01258           <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][0] &amp;&amp; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][0])
01259             <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][1] &amp;&amp; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][1])
01260               <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] &gt;= <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][2] &amp;&amp; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] &lt; <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o66">UpperCorner</a>[grnr][2])
01261                 {
01262                   <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
01263                     {
01264                       slab = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[j] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][j]);
01265 
01266                       <span class="keywordflow">if</span>(slab &lt; meshmin[j])
01267                         meshmin[j] = slab;
01268 
01269                       <span class="keywordflow">if</span>(slab &gt; meshmax[j])
01270                         meshmax[j] = slab;
01271                     }
01272                 }
01273         }
01274 
01275       MPI_Allgather(meshmin, 3, MPI_INT, meshmin_list, 3, MPI_INT, MPI_COMM_WORLD);
01276       MPI_Allgather(meshmax, 3, MPI_INT, meshmax_list, 3, MPI_INT, MPI_COMM_WORLD);
01277     }
01278 <span class="preprocessor">#endif</span>
01279 <span class="preprocessor"></span>
01280   dimx = meshmax[0] - meshmin[0] + 6;
01281   dimy = meshmax[1] - meshmin[1] + 6;
01282   dimz = meshmax[2] - meshmin[2] + 6;
01283 
01284   <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
01285     {
01286       <span class="keywordflow">if</span>(meshmin[j] &lt; 2)
01287         <a class="code" href="proto_8h.html#a38">endrun</a>(131231);
01288       <span class="keywordflow">if</span>(meshmax[j] &gt; GRID / 2 - 3)
01289         <a class="code" href="proto_8h.html#a38">endrun</a>(131288);
01290     }
01291 
01292   <span class="keywordflow">for</span>(level = 0; level &lt; (1 &lt;&lt; PTask); level++) <span class="comment">/* note: for level=0, target is the same task */</span>
01293     {
01294       sendTask = ThisTask;
01295       recvTask = <a class="code" href="allvars_8c.html#a0">ThisTask</a> ^ level;
01296 
01297       <span class="keywordflow">if</span>(recvTask &lt; NTask)
01298         {
01299           <span class="comment">/* check how much we have to send */</span>
01300           sendmin = 2 * GRID;
01301           sendmax = -GRID;
01302           <span class="keywordflow">for</span>(slab_x = meshmin_list[3 * recvTask] - 2; slab_x &lt; meshmax_list[3 * recvTask] + 4; slab_x++)
01303             <span class="keywordflow">if</span>(slab_to_task[slab_x] == sendTask)
01304               {
01305                 <span class="keywordflow">if</span>(slab_x &lt; sendmin)
01306                   sendmin = slab_x;
01307                 <span class="keywordflow">if</span>(slab_x &gt; sendmax)
01308                   sendmax = slab_x;
01309               }
01310           <span class="keywordflow">if</span>(sendmax == -GRID)
01311             sendmin = sendmax + 1;
01312 
01313 
01314           <span class="comment">/* check how much we have to receive */</span>
01315           recvmin = 2 * GRID;
01316           recvmax = -GRID;
01317           <span class="keywordflow">for</span>(slab_x = meshmin[0] - 2; slab_x &lt; meshmax[0] + 4; slab_x++)
01318             <span class="keywordflow">if</span>(slab_to_task[slab_x] == recvTask)
01319               {
01320                 <span class="keywordflow">if</span>(slab_x &lt; recvmin)
01321                   recvmin = slab_x;
01322                 <span class="keywordflow">if</span>(slab_x &gt; recvmax)
01323                   recvmax = slab_x;
01324               }
01325           <span class="keywordflow">if</span>(recvmax == -GRID)
01326             recvmin = recvmax + 1;
01327 
01328           <span class="keywordflow">if</span>((recvmax - recvmin) &gt;= 0 || (sendmax - sendmin) &gt;= 0)      <span class="comment">/* ok, we have a contribution to the slab */</span>
01329             {
01330               recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * recvTask + 0] + 6;
01331               recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * recvTask + 1] + 6;
01332               recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * recvTask + 2] + 6;
01333 
01334               <span class="comment">/* prepare what we want to send */</span>
01335               <span class="keywordflow">if</span>(sendmax - sendmin &gt;= 0)
01336                 {
01337                   <span class="keywordflow">for</span>(slab_x = sendmin; slab_x &lt;= sendmax; slab_x++)
01338                     {
01339                       slab_xx = slab_x - first_slab_of_task[ThisTask];
01340 
01341                       <span class="keywordflow">for</span>(slab_y = meshmin_list[3 * recvTask + 1] - 2;
01342                           slab_y &lt; meshmax_list[3 * recvTask + 1] + 4; slab_y++)
01343                         {
01344                           slab_yy = slab_y;
01345 
01346                           <span class="keywordflow">for</span>(slab_z = meshmin_list[3 * recvTask + 2] - 2;
01347                               slab_z &lt; meshmax_list[3 * recvTask + 2] + 4; slab_z++)
01348                             {
01349                               slab_zz = slab_z;
01350 
01351                               forcegrid[((slab_x - sendmin) * recv_dimy +
01352                                          (slab_y - (meshmin_list[3 * recvTask + 1] - 2))) * recv_dimz +
01353                                         slab_z - (meshmin_list[3 * recvTask + 2] - 2)] =
01354                                 rhogrid[GRID * GRID2 * slab_xx + GRID2 * slab_yy + slab_zz];
01355                             }
01356                         }
01357                     }
01358                 }
01359 
01360               <span class="keywordflow">if</span>(level &gt; 0)
01361                 {
01362                   MPI_Sendrecv(forcegrid,
01363                                (sendmax - sendmin + 1) * recv_dimy * recv_dimz * <span class="keyword">sizeof</span>(fftw_real),
01364                                MPI_BYTE, recvTask, TAG_NONPERIOD_D,
01365                                workspace + (recvmin - (meshmin[0] - 2)) * dimy * dimz,
01366                                (recvmax - recvmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real), MPI_BYTE,
01367                                recvTask, TAG_NONPERIOD_D, MPI_COMM_WORLD, &amp;status);
01368                 }
01369               <span class="keywordflow">else</span>
01370                 {
01371                   memcpy(workspace + (recvmin - (meshmin[0] - 2)) * dimy * dimz,
01372                          forcegrid, (recvmax - recvmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real));
01373                 }
01374             }
01375         }
01376     }
01377 
01378   dimx = meshmax[0] - meshmin[0] + 2;
01379   dimy = meshmax[1] - meshmin[1] + 2;
01380   dimz = meshmax[2] - meshmin[2] + 2;
01381 
01382   recv_dimx = meshmax[0] - meshmin[0] + 6;
01383   recv_dimy = meshmax[1] - meshmin[1] + 6;
01384   recv_dimz = meshmax[2] - meshmin[2] + 6;
01385 
01386 
01387   <span class="keywordflow">for</span>(x = 0; x &lt; meshmax[0] - meshmin[0] + 2; x++)
01388     <span class="keywordflow">for</span>(y = 0; y &lt; meshmax[1] - meshmin[1] + 2; y++)
01389       <span class="keywordflow">for</span>(z = 0; z &lt; meshmax[2] - meshmin[2] + 2; z++)
01390         {
01391           forcegrid[(x * dimy + y) * dimz + z]
01392             = workspace[((x + 2) * recv_dimy + (y + 2)) * recv_dimz + (z + 2)];
01393         }
01394 
01395 
01396   <span class="comment">/* read out the potential */</span>
01397 
01398   <span class="keywordflow">for</span>(i = 0; i &lt; NumPart; i++)
01399     {
01400 <span class="preprocessor">#ifdef PLACEHIGHRESREGION</span>
01401 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(grnr == 1)
01402         <span class="keywordflow">if</span>(!((1 &lt;&lt; <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o9">Type</a>) &amp; (PLACEHIGHRESREGION)))
01403           <span class="keywordflow">continue</span>;
01404 <span class="preprocessor">#endif</span>
01405 <span class="preprocessor"></span>      slab_x = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][0]);
01406       dx = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][0]) - slab_x;
01407       slab_x -= meshmin[0];
01408       slab_xx = slab_x + 1;
01409 
01410       slab_y = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][1]);
01411       dy = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][1]) - slab_y;
01412       slab_y -= meshmin[1];
01413       slab_yy = slab_y + 1;
01414 
01415       slab_z = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][2]);
01416       dz = to_slab_fac * (<a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] - <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o65">Corner</a>[grnr][2]) - slab_z;
01417       slab_z -= meshmin[2];
01418       slab_zz = slab_z + 1;
01419 
01420       pot = forcegrid[(slab_x * dimy + slab_y) * dimz + slab_z] * (1.0 - dx) * (1.0 - dy) * (1.0 - dz);
01421       pot += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_z] * (1.0 - dx) * dy * (1.0 - dz);
01422       pot += forcegrid[(slab_x * dimy + slab_y) * dimz + slab_zz] * (1.0 - dx) * (1.0 - dy) * dz;
01423       pot += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_zz] * (1.0 - dx) * dy * dz;
01424 
01425       pot += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_z] * (dx) * (1.0 - dy) * (1.0 - dz);
01426       pot += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_z] * (dx) * dy * (1.0 - dz);
01427       pot += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_zz] * (dx) * (1.0 - dy) * dz;
01428       pot += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_zz] * (dx) * dy * dz;
01429 
01430       <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o6">Potential</a> += pot;
01431     }
01432 
01433   <a class="code" href="proto_8h.html#a123">pm_init_nonperiodic_free</a>();
01434   <a class="code" href="proto_8h.html#a57">force_treeallocate</a>(<a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o15">TreeAllocFactor</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o2">MaxPart</a>, <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o2">MaxPart</a>);
01435   <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o23">NumForcesSinceLastDomainDecomp</a> = 1 + <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o0">TotNumPart</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o96">TreeDomainUpdateFrequency</a>;
01436 
01437   <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
01438     printf(<span class="stringliteral">"done PM-potential.\n"</span>);
01439 
01440   <span class="keywordflow">return</span> 0;
01441 }
01442 
01443 
01444 <span class="preprocessor">#endif</span>
01445 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Apr 22 15:29:41 2006 for GADGET-2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
