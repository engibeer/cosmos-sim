<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>GADGET-2: pm_periodic.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>pm_periodic.c</h1><a href="pm__periodic_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00002 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00003 <span class="preprocessor">#include &lt;string.h&gt;</span>
00004 <span class="preprocessor">#include &lt;math.h&gt;</span>
00005 <span class="preprocessor">#include &lt;float.h&gt;</span>
00006 <span class="preprocessor">#include &lt;mpi.h&gt;</span>
00007 
00012 <span class="preprocessor">#ifdef PMGRID</span>
00013 <span class="preprocessor"></span><span class="preprocessor">#ifdef PERIODIC</span>
00014 <span class="preprocessor"></span>
00015 <span class="preprocessor">#ifdef NOTYPEPREFIX_FFTW</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#include        &lt;rfftw_mpi.h&gt;</span>
00017 <span class="preprocessor">#else</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#ifdef DOUBLEPRECISION_FFTW</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#include     &lt;drfftw_mpi.h&gt;</span>     <span class="comment">/* double precision FFTW */</span>
00020 <span class="preprocessor">#else</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#include     &lt;srfftw_mpi.h&gt;</span>
00022 <span class="preprocessor">#endif</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span>
00025 
00026 <span class="preprocessor">#include "<a class="code" href="allvars_8h.html">allvars.h</a>"</span>
00027 <span class="preprocessor">#include "<a class="code" href="proto_8h.html">proto.h</a>"</span>
00028 
<a name="l00029"></a><a class="code" href="pm__periodic_8c.html#a0">00029</a> <span class="preprocessor">#define  PMGRID2 (2*(PMGRID/2 + 1))</span>
00030 <span class="preprocessor"></span>
00031 
00032 
00033 
00034 <span class="keyword">static</span> rfftwnd_mpi_plan fft_forward_plan, fft_inverse_plan;
00035 
00036 <span class="keyword">static</span> <span class="keywordtype">int</span> slab_to_task[PMGRID];
00037 <span class="keyword">static</span> <span class="keywordtype">int</span> *slabs_per_task;
00038 <span class="keyword">static</span> <span class="keywordtype">int</span> *first_slab_of_task;
00039 <span class="keyword">static</span> <span class="keywordtype">int</span> *meshmin_list, *meshmax_list;
00040 
00041 <span class="keyword">static</span> <span class="keywordtype">int</span> slabstart_x, nslab_x, slabstart_y, nslab_y, smallest_slab;
00042 
00043 <span class="keyword">static</span> <span class="keywordtype">int</span> fftsize, maxfftsize;
00044 
00045 <span class="keyword">static</span> fftw_real *rhogrid, *forcegrid, *workspace;
00046 <span class="keyword">static</span> fftw_complex *fft_of_rhogrid;
00047 
00048 
00049 <span class="keyword">static</span> <a class="code" href="allvars_8h.html#a35">FLOAT</a> to_slab_fac;
00050 
00051 
<a name="l00055"></a><a class="code" href="proto_8h.html#a124">00055</a> <span class="keywordtype">void</span> <a class="code" href="pm__periodic_8c.html#a20">pm_init_periodic</a>(<span class="keywordtype">void</span>)
00056 {
00057   <span class="keywordtype">int</span> i;
00058   <span class="keywordtype">int</span> slab_to_task_local[PMGRID];
00059 
00060   <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o63">Asmth</a>[0] = <a class="code" href="allvars_8h.html#a29">ASMTH</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o4">BoxSize</a> / PMGRID;
00061   <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o64">Rcut</a>[0] = <a class="code" href="allvars_8h.html#a30">RCUT</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o63">Asmth</a>[0];
00062 
00063   <span class="comment">/* Set up the FFTW plan files. */</span>
00064 
00065   fft_forward_plan = rfftw3d_mpi_create_plan(MPI_COMM_WORLD, PMGRID, PMGRID, PMGRID,
00066                                              FFTW_REAL_TO_COMPLEX, FFTW_ESTIMATE | FFTW_IN_PLACE);
00067   fft_inverse_plan = rfftw3d_mpi_create_plan(MPI_COMM_WORLD, PMGRID, PMGRID, PMGRID,
00068                                              FFTW_COMPLEX_TO_REAL, FFTW_ESTIMATE | FFTW_IN_PLACE);
00069 
00070   <span class="comment">/* Workspace out the ranges on each processor. */</span>
00071 
00072   rfftwnd_mpi_local_sizes(fft_forward_plan, &amp;nslab_x, &amp;slabstart_x, &amp;nslab_y, &amp;slabstart_y, &amp;fftsize);
00073 
00074   <span class="keywordflow">for</span>(i = 0; i &lt; PMGRID; i++)
00075     slab_to_task_local[i] = 0;
00076 
00077   <span class="keywordflow">for</span>(i = 0; i &lt; nslab_x; i++)
00078     slab_to_task_local[slabstart_x + i] = ThisTask;
00079 
00080   MPI_Allreduce(slab_to_task_local, slab_to_task, PMGRID, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
00081 
00082   MPI_Allreduce(&amp;nslab_x, &amp;smallest_slab, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);
00083 
00084   slabs_per_task = malloc(<a class="code" href="allvars_8c.html#a1">NTask</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00085   MPI_Allgather(&amp;nslab_x, 1, MPI_INT, slabs_per_task, 1, MPI_INT, MPI_COMM_WORLD);
00086 
00087   <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
00088     {
00089       <span class="keywordflow">for</span>(i = 0; i &lt; NTask; i++)
00090         printf(<span class="stringliteral">"Task=%d  FFT-Slabs=%d\n"</span>, i, slabs_per_task[i]);
00091     }
00092 
00093   first_slab_of_task = malloc(<a class="code" href="allvars_8c.html#a1">NTask</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00094   MPI_Allgather(&amp;slabstart_x, 1, MPI_INT, first_slab_of_task, 1, MPI_INT, MPI_COMM_WORLD);
00095 
00096   meshmin_list = malloc(3 * <a class="code" href="allvars_8c.html#a1">NTask</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00097   meshmax_list = malloc(3 * <a class="code" href="allvars_8c.html#a1">NTask</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00098 
00099 
00100   to_slab_fac = PMGRID / <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o4">BoxSize</a>;
00101 
00102   MPI_Allreduce(&amp;fftsize, &amp;maxfftsize, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);
00103 }
00104 
00105 
00113 <span class="keywordtype">void</span> <a class="code" href="proto_8h.html#a125">pm_init_periodic_allocate</a>(<span class="keywordtype">int</span> dimprod)
<a name="l00114"></a><a class="code" href="proto_8h.html#a125">00114</a> {
00115   <span class="keyword">static</span> <span class="keywordtype">int</span> first_alloc = 1;
00116   <span class="keywordtype">int</span> dimprodmax;
00117   <span class="keywordtype">double</span> bytes_tot = 0;
00118   size_t bytes;
00119 
00120   MPI_Allreduce(&amp;dimprod, &amp;dimprodmax, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);
00121 
00122   <span class="comment">/* allocate the memory to hold the FFT fields */</span>
00123 
00124   <span class="keywordflow">if</span>(!(rhogrid = (fftw_real *) malloc(bytes = fftsize * <span class="keyword">sizeof</span>(fftw_real))))
00125     {
00126       printf(<span class="stringliteral">"failed to allocate memory for `FFT-rhogrid' (%g MB).\n"</span>, bytes / (1024.0 * 1024.0));
00127       <a class="code" href="proto_8h.html#a38">endrun</a>(1);
00128     }
00129   bytes_tot += bytes;
00130 
00131 
00132   <span class="keywordflow">if</span>(!(forcegrid = (fftw_real *) malloc(bytes = <a class="code" href="system_8c.html#a6">imax</a>(fftsize, dimprodmax) * <span class="keyword">sizeof</span>(fftw_real))))
00133     {
00134       printf(<span class="stringliteral">"failed to allocate memory for `FFT-forcegrid' (%g MB).\n"</span>, bytes / (1024.0 * 1024.0));
00135       <a class="code" href="proto_8h.html#a38">endrun</a>(1);
00136     }
00137   bytes_tot += bytes;
00138 
00139   <span class="keywordflow">if</span>(!(workspace = (fftw_real *) malloc(bytes = <a class="code" href="system_8c.html#a6">imax</a>(maxfftsize, dimprodmax) * <span class="keyword">sizeof</span>(fftw_real))))
00140     {
00141       printf(<span class="stringliteral">"failed to allocate memory for `FFT-workspace' (%g MB).\n"</span>, bytes / (1024.0 * 1024.0));
00142       <a class="code" href="proto_8h.html#a38">endrun</a>(1);
00143     }
00144   bytes_tot += bytes;
00145 
00146   <span class="keywordflow">if</span>(first_alloc == 1)
00147     {
00148       first_alloc = 0;
00149       <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
00150         printf(<span class="stringliteral">"\nAllocated %g MByte for FFT data.\n\n"</span>, bytes_tot / (1024.0 * 1024.0));
00151     }
00152 
00153   fft_of_rhogrid = (fftw_complex *) &amp; rhogrid[0];
00154 }
00155 
00156 
00157 
00160 <span class="keywordtype">void</span> <a class="code" href="pm__periodic_8c.html#a22">pm_init_periodic_free</a>(<span class="keywordtype">void</span>)
<a name="l00161"></a><a class="code" href="proto_8h.html#a126">00161</a> {
00162   <span class="comment">/* allocate the memory to hold the FFT fields */</span>
00163   free(workspace);
00164   free(forcegrid);
00165   free(rhogrid);
00166 }
00167 
00168 
00169 
00180 <span class="keywordtype">void</span> <a class="code" href="pm__periodic_8c.html#a23">pmforce_periodic</a>(<span class="keywordtype">void</span>)
<a name="l00181"></a><a class="code" href="proto_8h.html#a130">00181</a> {
00182   <span class="keywordtype">double</span> k2, kx, ky, kz, smth;
00183   <span class="keywordtype">double</span> dx, dy, dz;
00184   <span class="keywordtype">double</span> fx, fy, fz, ff;
00185   <span class="keywordtype">double</span> asmth2, fac, acc_dim;
00186   <span class="keywordtype">int</span> i, j, slab, level, sendTask, recvTask;
00187   <span class="keywordtype">int</span> x, y, z, xl, yl, zl, xr, yr, zr, xll, yll, zll, xrr, yrr, zrr, ip, dim;
00188   <span class="keywordtype">int</span> slab_x, slab_y, slab_z;
00189   <span class="keywordtype">int</span> slab_xx, slab_yy, slab_zz;
00190   <span class="keywordtype">int</span> meshmin[3], meshmax[3], sendmin, sendmax, recvmin, recvmax;
00191   <span class="keywordtype">int</span> rep, ncont, cont_sendmin[2], cont_sendmax[2], cont_recvmin[2], cont_recvmax[2];
00192   <span class="keywordtype">int</span> dimx, dimy, dimz, recv_dimx, recv_dimy, recv_dimz;
00193   MPI_Status status;
00194 
00195 
00196   <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
00197     {
00198       printf(<span class="stringliteral">"Starting periodic PM calculation.\n"</span>);
00199       fflush(stdout);
00200     }
00201 
00202 
00203   <a class="code" href="forcetree_8c.html#a34">force_treefree</a>();
00204 
00205 
00206   asmth2 = (2 * M_PI) * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o63">Asmth</a>[0] / <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o4">BoxSize</a>;
00207   asmth2 *= asmth2;
00208 
00209   fac = <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o24">G</a> / (M_PI * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o4">BoxSize</a>);   <span class="comment">/* to get potential */</span>
00210   fac *= 1 / (2 * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o4">BoxSize</a> / PMGRID);        <span class="comment">/* for finite differencing */</span>
00211 
00212   <span class="comment">/* first, establish the extension of the local patch in the PMGRID  */</span>
00213 
00214   <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
00215     {
00216       meshmin[j] = PMGRID;
00217       meshmax[j] = 0;
00218     }
00219 
00220   <span class="keywordflow">for</span>(i = 0; i &lt; NumPart; i++)
00221     {
00222       <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
00223         {
00224           slab = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[j];
00225           <span class="keywordflow">if</span>(slab &gt;= PMGRID)
00226             slab = PMGRID - 1;
00227 
00228           <span class="keywordflow">if</span>(slab &lt; meshmin[j])
00229             meshmin[j] = slab;
00230 
00231           <span class="keywordflow">if</span>(slab &gt; meshmax[j])
00232             meshmax[j] = slab;
00233         }
00234     }
00235 
00236   MPI_Allgather(meshmin, 3, MPI_INT, meshmin_list, 3, MPI_INT, MPI_COMM_WORLD);
00237   MPI_Allgather(meshmax, 3, MPI_INT, meshmax_list, 3, MPI_INT, MPI_COMM_WORLD);
00238 
00239   dimx = meshmax[0] - meshmin[0] + 2;
00240   dimy = meshmax[1] - meshmin[1] + 2;
00241   dimz = meshmax[2] - meshmin[2] + 2;
00242 
00243   <a class="code" href="proto_8h.html#a125">pm_init_periodic_allocate</a>((dimx + 4) * (dimy + 4) * (dimz + 4));
00244 
00245   <span class="keywordflow">for</span>(i = 0; i &lt; dimx * dimy * dimz; i++)
00246     workspace[i] = 0;
00247 
00248   <span class="keywordflow">for</span>(i = 0; i &lt; NumPart; i++)
00249     {
00250       slab_x = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0];
00251       <span class="keywordflow">if</span>(slab_x &gt;= PMGRID)
00252         slab_x = PMGRID - 1;
00253       dx = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] - slab_x;
00254       slab_x -= meshmin[0];
00255       slab_xx = slab_x + 1;
00256 
00257       slab_y = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1];
00258       <span class="keywordflow">if</span>(slab_y &gt;= PMGRID)
00259         slab_y = PMGRID - 1;
00260       dy = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] - slab_y;
00261       slab_y -= meshmin[1];
00262       slab_yy = slab_y + 1;
00263 
00264       slab_z = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2];
00265       <span class="keywordflow">if</span>(slab_z &gt;= PMGRID)
00266         slab_z = PMGRID - 1;
00267       dz = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] - slab_z;
00268       slab_z -= meshmin[2];
00269       slab_zz = slab_z + 1;
00270 
00271       workspace[(slab_x * dimy + slab_y) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * (1.0 - dy) * (1.0 - dz);
00272       workspace[(slab_x * dimy + slab_yy) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * dy * (1.0 - dz);
00273       workspace[(slab_x * dimy + slab_y) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * (1.0 - dy) * dz;
00274       workspace[(slab_x * dimy + slab_yy) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * dy * dz;
00275 
00276       workspace[(slab_xx * dimy + slab_y) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * (1.0 - dy) * (1.0 - dz);
00277       workspace[(slab_xx * dimy + slab_yy) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * dy * (1.0 - dz);
00278       workspace[(slab_xx * dimy + slab_y) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * (1.0 - dy) * dz;
00279       workspace[(slab_xx * dimy + slab_yy) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * dy * dz;
00280     }
00281 
00282 
00283   <span class="keywordflow">for</span>(i = 0; i &lt; fftsize; i++)  <span class="comment">/* clear local density field */</span>
00284     rhogrid[i] = 0;
00285 
00286   <span class="keywordflow">for</span>(level = 0; level &lt; (1 &lt;&lt; PTask); level++) <span class="comment">/* note: for level=0, target is the same task */</span>
00287     {
00288       sendTask = ThisTask;
00289       recvTask = <a class="code" href="allvars_8c.html#a0">ThisTask</a> ^ level;
00290       <span class="keywordflow">if</span>(recvTask &lt; NTask)
00291         {
00292           <span class="comment">/* check how much we have to send */</span>
00293           sendmin = 2 * PMGRID;
00294           sendmax = -1;
00295           <span class="keywordflow">for</span>(slab_x = meshmin[0]; slab_x &lt; meshmax[0] + 2; slab_x++)
00296             <span class="keywordflow">if</span>(slab_to_task[slab_x % PMGRID] == recvTask)
00297               {
00298                 <span class="keywordflow">if</span>(slab_x &lt; sendmin)
00299                   sendmin = slab_x;
00300                 <span class="keywordflow">if</span>(slab_x &gt; sendmax)
00301                   sendmax = slab_x;
00302               }
00303           <span class="keywordflow">if</span>(sendmax == -1)
00304             sendmin = 0;
00305 
00306           <span class="comment">/* check how much we have to receive */</span>
00307           recvmin = 2 * PMGRID;
00308           recvmax = -1;
00309           <span class="keywordflow">for</span>(slab_x = meshmin_list[3 * recvTask]; slab_x &lt; meshmax_list[3 * recvTask] + 2; slab_x++)
00310             <span class="keywordflow">if</span>(slab_to_task[slab_x % PMGRID] == sendTask)
00311               {
00312                 <span class="keywordflow">if</span>(slab_x &lt; recvmin)
00313                   recvmin = slab_x;
00314                 <span class="keywordflow">if</span>(slab_x &gt; recvmax)
00315                   recvmax = slab_x;
00316               }
00317           <span class="keywordflow">if</span>(recvmax == -1)
00318             recvmin = 0;
00319 
00320 
00321           <span class="keywordflow">if</span>((recvmax - recvmin) &gt;= 0 || (sendmax - sendmin) &gt;= 0)      <span class="comment">/* ok, we have a contribution to the slab */</span>
00322             {
00323               recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * recvTask + 0] + 2;
00324               recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * recvTask + 1] + 2;
00325               recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * recvTask + 2] + 2;
00326 
00327               <span class="keywordflow">if</span>(level &gt; 0)
00328                 {
00329                   MPI_Sendrecv(workspace + (sendmin - meshmin[0]) * dimy * dimz,
00330                                (sendmax - sendmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real), MPI_BYTE, recvTask,
00331                                <a class="code" href="tags_8h.html#a15">TAG_PERIODIC_A</a>, forcegrid,
00332                                (recvmax - recvmin + 1) * recv_dimy * recv_dimz * <span class="keyword">sizeof</span>(fftw_real), MPI_BYTE,
00333                                recvTask, <a class="code" href="tags_8h.html#a15">TAG_PERIODIC_A</a>, MPI_COMM_WORLD, &amp;status);
00334                 }
00335               <span class="keywordflow">else</span>
00336                 {
00337                   memcpy(forcegrid, workspace + (sendmin - meshmin[0]) * dimy * dimz,
00338                          (sendmax - sendmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real));
00339                 }
00340 
00341               <span class="keywordflow">for</span>(slab_x = recvmin; slab_x &lt;= recvmax; slab_x++)
00342                 {
00343                   slab_xx = (slab_x % PMGRID) - first_slab_of_task[ThisTask];
00344 
00345                   <span class="keywordflow">if</span>(slab_xx &gt;= 0 &amp;&amp; slab_xx &lt; slabs_per_task[ThisTask])
00346                     {
00347                       <span class="keywordflow">for</span>(slab_y = meshmin_list[3 * recvTask + 1];
00348                           slab_y &lt;= meshmax_list[3 * recvTask + 1] + 1; slab_y++)
00349                         {
00350                           slab_yy = slab_y;
00351                           <span class="keywordflow">if</span>(slab_yy &gt;= PMGRID)
00352                             slab_yy -= PMGRID;
00353 
00354                           <span class="keywordflow">for</span>(slab_z = meshmin_list[3 * recvTask + 2];
00355                               slab_z &lt;= meshmax_list[3 * recvTask + 2] + 1; slab_z++)
00356                             {
00357                               slab_zz = slab_z;
00358                               <span class="keywordflow">if</span>(slab_zz &gt;= PMGRID)
00359                                 slab_zz -= PMGRID;
00360 
00361                               rhogrid[PMGRID * <a class="code" href="pm__periodic_8c.html#a0">PMGRID2</a> * slab_xx + <a class="code" href="pm__periodic_8c.html#a0">PMGRID2</a> * slab_yy + slab_zz] +=
00362                                 forcegrid[((slab_x - recvmin) * recv_dimy +
00363                                            (slab_y - meshmin_list[3 * recvTask + 1])) * recv_dimz +
00364                                           (slab_z - meshmin_list[3 * recvTask + 2])];
00365                             }
00366                         }
00367                     }
00368                 }
00369             }
00370         }
00371     }
00372 
00373   <span class="comment">/* Do the FFT of the density field */</span>
00374 
00375   rfftwnd_mpi(fft_forward_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);
00376 
00377   <span class="comment">/* multiply with Green's function for the potential */</span>
00378 
00379   <span class="keywordflow">for</span>(y = slabstart_y; y &lt; slabstart_y + nslab_y; y++)
00380     <span class="keywordflow">for</span>(x = 0; x &lt; PMGRID; x++)
00381       <span class="keywordflow">for</span>(z = 0; z &lt; PMGRID / 2 + 1; z++)
00382         {
00383           <span class="keywordflow">if</span>(x &gt; PMGRID / 2)
00384             kx = x - PMGRID;
00385           <span class="keywordflow">else</span>
00386             kx = x;
00387           <span class="keywordflow">if</span>(y &gt; PMGRID / 2)
00388             ky = y - PMGRID;
00389           <span class="keywordflow">else</span>
00390             ky = y;
00391           <span class="keywordflow">if</span>(z &gt; PMGRID / 2)
00392             kz = z - PMGRID;
00393           <span class="keywordflow">else</span>
00394             kz = z;
00395 
00396           k2 = kx * kx + ky * ky + kz * kz;
00397 
00398           <span class="keywordflow">if</span>(k2 &gt; 0)
00399             {
00400               smth = -exp(-k2 * asmth2) / k2;
00401 
00402               <span class="comment">/* do deconvolution */</span>
00403 
00404               fx = fy = fz = 1;
00405               <span class="keywordflow">if</span>(kx != 0)
00406                 {
00407                   fx = (M_PI * kx) / PMGRID;
00408                   fx = sin(fx) / fx;
00409                 }
00410               <span class="keywordflow">if</span>(ky != 0)
00411                 {
00412                   fy = (M_PI * ky) / PMGRID;
00413                   fy = sin(fy) / fy;
00414                 }
00415               <span class="keywordflow">if</span>(kz != 0)
00416                 {
00417                   fz = (M_PI * kz) / PMGRID;
00418                   fz = sin(fz) / fz;
00419                 }
00420               ff = 1 / (fx * fy * fz);
00421               smth *= ff * ff * ff * ff;
00422 
00423               <span class="comment">/* end deconvolution */</span>
00424 
00425               ip = PMGRID * (PMGRID / 2 + 1) * (y - slabstart_y) + (PMGRID / 2 + 1) * x + z;
00426               fft_of_rhogrid[ip].re *= smth;
00427               fft_of_rhogrid[ip].im *= smth;
00428             }
00429         }
00430 
00431   <span class="keywordflow">if</span>(slabstart_y == 0)
00432     fft_of_rhogrid[0].re = fft_of_rhogrid[0].im = 0.0;
00433 
00434   <span class="comment">/* Do the FFT to get the potential */</span>
00435 
00436   rfftwnd_mpi(fft_inverse_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);
00437 
00438   <span class="comment">/* Now rhogrid holds the potential */</span>
00439   <span class="comment">/* construct the potential for the local patch */</span>
00440 
00441 
00442   dimx = meshmax[0] - meshmin[0] + 6;
00443   dimy = meshmax[1] - meshmin[1] + 6;
00444   dimz = meshmax[2] - meshmin[2] + 6;
00445 
00446   <span class="keywordflow">for</span>(level = 0; level &lt; (1 &lt;&lt; PTask); level++) <span class="comment">/* note: for level=0, target is the same task */</span>
00447     {
00448       sendTask = ThisTask;
00449       recvTask = <a class="code" href="allvars_8c.html#a0">ThisTask</a> ^ level;
00450 
00451       <span class="keywordflow">if</span>(recvTask &lt; NTask)
00452         {
00453 
00454           <span class="comment">/* check how much we have to send */</span>
00455           sendmin = 2 * PMGRID;
00456           sendmax = -PMGRID;
00457           <span class="keywordflow">for</span>(slab_x = meshmin_list[3 * recvTask] - 2; slab_x &lt; meshmax_list[3 * recvTask] + 4; slab_x++)
00458             <span class="keywordflow">if</span>(slab_to_task[(slab_x + PMGRID) % PMGRID] == sendTask)
00459               {
00460                 <span class="keywordflow">if</span>(slab_x &lt; sendmin)
00461                   sendmin = slab_x;
00462                 <span class="keywordflow">if</span>(slab_x &gt; sendmax)
00463                   sendmax = slab_x;
00464               }
00465           <span class="keywordflow">if</span>(sendmax == -PMGRID)
00466             sendmin = sendmax + 1;
00467 
00468 
00469           <span class="comment">/* check how much we have to receive */</span>
00470           recvmin = 2 * PMGRID;
00471           recvmax = -PMGRID;
00472           <span class="keywordflow">for</span>(slab_x = meshmin[0] - 2; slab_x &lt; meshmax[0] + 4; slab_x++)
00473             <span class="keywordflow">if</span>(slab_to_task[(slab_x + PMGRID) % PMGRID] == recvTask)
00474               {
00475                 <span class="keywordflow">if</span>(slab_x &lt; recvmin)
00476                   recvmin = slab_x;
00477                 <span class="keywordflow">if</span>(slab_x &gt; recvmax)
00478                   recvmax = slab_x;
00479               }
00480           <span class="keywordflow">if</span>(recvmax == -PMGRID)
00481             recvmin = recvmax + 1;
00482 
00483           <span class="keywordflow">if</span>((recvmax - recvmin) &gt;= 0 || (sendmax - sendmin) &gt;= 0)      <span class="comment">/* ok, we have a contribution to the slab */</span>
00484             {
00485               recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * recvTask + 0] + 6;
00486               recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * recvTask + 1] + 6;
00487               recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * recvTask + 2] + 6;
00488 
00489               ncont = 1;
00490               cont_sendmin[0] = sendmin;
00491               cont_sendmax[0] = sendmax;
00492               cont_sendmin[1] = sendmax + 1;
00493               cont_sendmax[1] = sendmax;
00494 
00495               cont_recvmin[0] = recvmin;
00496               cont_recvmax[0] = recvmax;
00497               cont_recvmin[1] = recvmax + 1;
00498               cont_recvmax[1] = recvmax;
00499 
00500               <span class="keywordflow">for</span>(slab_x = sendmin; slab_x &lt;= sendmax; slab_x++)
00501                 {
00502                   <span class="keywordflow">if</span>(slab_to_task[(slab_x + PMGRID) % PMGRID] != ThisTask)
00503                     {
00504                       <span class="comment">/* non-contiguous */</span>
00505                       cont_sendmax[0] = slab_x - 1;
00506                       <span class="keywordflow">while</span>(slab_to_task[(slab_x + PMGRID) % PMGRID] != ThisTask)
00507                         slab_x++;
00508                       cont_sendmin[1] = slab_x;
00509                       ncont++;
00510                     }
00511                 }
00512 
00513               <span class="keywordflow">for</span>(slab_x = recvmin; slab_x &lt;= recvmax; slab_x++)
00514                 {
00515                   <span class="keywordflow">if</span>(slab_to_task[(slab_x + PMGRID) % PMGRID] != recvTask)
00516                     {
00517                       <span class="comment">/* non-contiguous */</span>
00518                       cont_recvmax[0] = slab_x - 1;
00519                       <span class="keywordflow">while</span>(slab_to_task[(slab_x + PMGRID) % PMGRID] != recvTask)
00520                         slab_x++;
00521                       cont_recvmin[1] = slab_x;
00522                       <span class="keywordflow">if</span>(ncont == 1)
00523                         ncont++;
00524                     }
00525                 }
00526 
00527 
00528               <span class="keywordflow">for</span>(rep = 0; rep &lt; ncont; rep++)
00529                 {
00530                   sendmin = cont_sendmin[rep];
00531                   sendmax = cont_sendmax[rep];
00532                   recvmin = cont_recvmin[rep];
00533                   recvmax = cont_recvmax[rep];
00534 
00535                   <span class="comment">/* prepare what we want to send */</span>
00536                   <span class="keywordflow">if</span>(sendmax - sendmin &gt;= 0)
00537                     {
00538                       <span class="keywordflow">for</span>(slab_x = sendmin; slab_x &lt;= sendmax; slab_x++)
00539                         {
00540                           slab_xx = ((slab_x + PMGRID) % PMGRID) - first_slab_of_task[ThisTask];
00541 
00542                           <span class="keywordflow">for</span>(slab_y = meshmin_list[3 * recvTask + 1] - 2;
00543                               slab_y &lt; meshmax_list[3 * recvTask + 1] + 4; slab_y++)
00544                             {
00545                               slab_yy = (slab_y + PMGRID) % PMGRID;
00546 
00547                               <span class="keywordflow">for</span>(slab_z = meshmin_list[3 * recvTask + 2] - 2;
00548                                   slab_z &lt;= meshmax_list[3 * recvTask + 2] + 4; slab_z++)
00549                                 {
00550                                   slab_zz = (slab_z + PMGRID) % PMGRID;
00551 
00552                                   forcegrid[((slab_x - sendmin) * recv_dimy +
00553                                              (slab_y - (meshmin_list[3 * recvTask + 1] - 2))) * recv_dimz +
00554                                             slab_z - (meshmin_list[3 * recvTask + 2] - 2)] =
00555                                     rhogrid[PMGRID * <a class="code" href="pm__periodic_8c.html#a0">PMGRID2</a> * slab_xx + <a class="code" href="pm__periodic_8c.html#a0">PMGRID2</a> * slab_yy + slab_zz];
00556                                 }
00557                             }
00558                         }
00559                     }
00560 
00561                   <span class="keywordflow">if</span>(level &gt; 0)
00562                     {
00563                       MPI_Sendrecv(forcegrid,
00564                                    (sendmax - sendmin + 1) * recv_dimy * recv_dimz * <span class="keyword">sizeof</span>(fftw_real),
00565                                    MPI_BYTE, recvTask, <a class="code" href="tags_8h.html#a16">TAG_PERIODIC_B</a>,
00566                                    workspace + (recvmin - (meshmin[0] - 2)) * dimy * dimz,
00567                                    (recvmax - recvmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real), MPI_BYTE,
00568                                    recvTask, <a class="code" href="tags_8h.html#a16">TAG_PERIODIC_B</a>, MPI_COMM_WORLD, &amp;status);
00569                     }
00570                   <span class="keywordflow">else</span>
00571                     {
00572                       memcpy(workspace + (recvmin - (meshmin[0] - 2)) * dimy * dimz,
00573                              forcegrid, (recvmax - recvmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real));
00574                     }
00575                 }
00576             }
00577         }
00578     }
00579 
00580 
00581   dimx = meshmax[0] - meshmin[0] + 2;
00582   dimy = meshmax[1] - meshmin[1] + 2;
00583   dimz = meshmax[2] - meshmin[2] + 2;
00584 
00585   recv_dimx = meshmax[0] - meshmin[0] + 6;
00586   recv_dimy = meshmax[1] - meshmin[1] + 6;
00587   recv_dimz = meshmax[2] - meshmin[2] + 6;
00588 
00589 
00590   <span class="keywordflow">for</span>(dim = 0; dim &lt; 3; dim++)  <span class="comment">/* Calculate each component of the force. */</span>
00591     {
00592       <span class="comment">/* get the force component by finite differencing the potential */</span>
00593       <span class="comment">/* note: "workspace" now contains the potential for the local patch, plus a suffiently large buffer region */</span>
00594 
00595       <span class="keywordflow">for</span>(x = 0; x &lt; meshmax[0] - meshmin[0] + 2; x++)
00596         <span class="keywordflow">for</span>(y = 0; y &lt; meshmax[1] - meshmin[1] + 2; y++)
00597           <span class="keywordflow">for</span>(z = 0; z &lt; meshmax[2] - meshmin[2] + 2; z++)
00598             {
00599               xrr = xll = xr = xl = x;
00600               yrr = yll = yr = yl = y;
00601               zrr = zll = zr = zl = z;
00602 
00603               <span class="keywordflow">switch</span> (dim)
00604                 {
00605                 <span class="keywordflow">case</span> 0:
00606                   xr = x + 1;
00607                   xrr = x + 2;
00608                   xl = x - 1;
00609                   xll = x - 2;
00610                   <span class="keywordflow">break</span>;
00611                 <span class="keywordflow">case</span> 1:
00612                   yr = y + 1;
00613                   yl = y - 1;
00614                   yrr = y + 2;
00615                   yll = y - 2;
00616                   <span class="keywordflow">break</span>;
00617                 <span class="keywordflow">case</span> 2:
00618                   zr = z + 1;
00619                   zl = z - 1;
00620                   zrr = z + 2;
00621                   zll = z - 2;
00622                   <span class="keywordflow">break</span>;
00623                 }
00624 
00625               forcegrid[(x * dimy + y) * dimz + z]
00626                 =
00627                 fac * ((4.0 / 3) *
00628                        (workspace[((xl + 2) * recv_dimy + (yl + 2)) * recv_dimz + (zl + 2)]
00629                         - workspace[((xr + 2) * recv_dimy + (yr + 2)) * recv_dimz + (zr + 2)]) -
00630                        (1.0 / 6) *
00631                        (workspace[((xll + 2) * recv_dimy + (yll + 2)) * recv_dimz + (zll + 2)] -
00632                         workspace[((xrr + 2) * recv_dimy + (yrr + 2)) * recv_dimz + (zrr + 2)]));
00633             }
00634 
00635       <span class="comment">/* read out the forces */</span>
00636 
00637       <span class="keywordflow">for</span>(i = 0; i &lt; NumPart; i++)
00638         {
00639           slab_x = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0];
00640           <span class="keywordflow">if</span>(slab_x &gt;= PMGRID)
00641             slab_x = PMGRID - 1;
00642           dx = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] - slab_x;
00643           slab_x -= meshmin[0];
00644           slab_xx = slab_x + 1;
00645 
00646           slab_y = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1];
00647           <span class="keywordflow">if</span>(slab_y &gt;= PMGRID)
00648             slab_y = PMGRID - 1;
00649           dy = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] - slab_y;
00650           slab_y -= meshmin[1];
00651           slab_yy = slab_y + 1;
00652 
00653           slab_z = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2];
00654           <span class="keywordflow">if</span>(slab_z &gt;= PMGRID)
00655             slab_z = PMGRID - 1;
00656           dz = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] - slab_z;
00657           slab_z -= meshmin[2];
00658           slab_zz = slab_z + 1;
00659 
00660           acc_dim =
00661             forcegrid[(slab_x * dimy + slab_y) * dimz + slab_z] * (1.0 - dx) * (1.0 - dy) * (1.0 - dz);
00662           acc_dim += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_z] * (1.0 - dx) * dy * (1.0 - dz);
00663           acc_dim += forcegrid[(slab_x * dimy + slab_y) * dimz + slab_zz] * (1.0 - dx) * (1.0 - dy) * dz;
00664           acc_dim += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_zz] * (1.0 - dx) * dy * dz;
00665 
00666           acc_dim += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_z] * (dx) * (1.0 - dy) * (1.0 - dz);
00667           acc_dim += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_z] * (dx) * dy * (1.0 - dz);
00668           acc_dim += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_zz] * (dx) * (1.0 - dy) * dz;
00669           acc_dim += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_zz] * (dx) * dy * dz;
00670 
00671           <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o4">GravPM</a>[dim] = acc_dim;
00672         }
00673     }
00674 
00675   <a class="code" href="pm__periodic_8c.html#a22">pm_init_periodic_free</a>();
00676   <a class="code" href="proto_8h.html#a57">force_treeallocate</a>(<a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o15">TreeAllocFactor</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o2">MaxPart</a>, <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o2">MaxPart</a>);
00677 
00678   <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o23">NumForcesSinceLastDomainDecomp</a> = 1 + <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o0">TotNumPart</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o96">TreeDomainUpdateFrequency</a>;
00679 
00680   <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
00681     {
00682       printf(<span class="stringliteral">"done PM.\n"</span>);
00683       fflush(stdout);
00684     }
00685 }
00686 
00687 
00693 <span class="keywordtype">void</span> <a class="code" href="pm__periodic_8c.html#a24">pmpotential_periodic</a>(<span class="keywordtype">void</span>)
<a name="l00694"></a><a class="code" href="proto_8h.html#a132">00694</a> {
00695   <span class="keywordtype">double</span> k2, kx, ky, kz, smth;
00696   <span class="keywordtype">double</span> dx, dy, dz;
00697   <span class="keywordtype">double</span> fx, fy, fz, ff;
00698   <span class="keywordtype">double</span> asmth2, fac;
00699   <span class="keywordtype">int</span> i, j, slab, level, sendTask, recvTask;
00700   <span class="keywordtype">int</span> x, y, z, ip;
00701   <span class="keywordtype">int</span> slab_x, slab_y, slab_z;
00702   <span class="keywordtype">int</span> slab_xx, slab_yy, slab_zz;
00703   <span class="keywordtype">int</span> meshmin[3], meshmax[3], sendmin, sendmax, recvmin, recvmax;
00704   <span class="keywordtype">int</span> rep, ncont, cont_sendmin[2], cont_sendmax[2], cont_recvmin[2], cont_recvmax[2];
00705   <span class="keywordtype">int</span> dimx, dimy, dimz, recv_dimx, recv_dimy, recv_dimz;
00706   MPI_Status status;
00707 
00708   <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
00709     {
00710       printf(<span class="stringliteral">"Starting periodic PM calculation.\n"</span>);
00711       fflush(stdout);
00712     }
00713 
00714   asmth2 = (2 * M_PI) * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o63">Asmth</a>[0] / <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o4">BoxSize</a>;
00715   asmth2 *= asmth2;
00716 
00717   fac = <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o24">G</a> / (M_PI * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o4">BoxSize</a>);   <span class="comment">/* to get potential */</span>
00718 
00719   <a class="code" href="forcetree_8c.html#a34">force_treefree</a>();
00720 
00721   <span class="comment">/* first, establish the extension of the local patch in the PMGRID  */</span>
00722 
00723   <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
00724     {
00725       meshmin[j] = PMGRID;
00726       meshmax[j] = 0;
00727     }
00728 
00729   <span class="keywordflow">for</span>(i = 0; i &lt; NumPart; i++)
00730     {
00731       <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
00732         {
00733           slab = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[j];
00734           <span class="keywordflow">if</span>(slab &gt;= PMGRID)
00735             slab = PMGRID - 1;
00736 
00737           <span class="keywordflow">if</span>(slab &lt; meshmin[j])
00738             meshmin[j] = slab;
00739 
00740           <span class="keywordflow">if</span>(slab &gt; meshmax[j])
00741             meshmax[j] = slab;
00742         }
00743     }
00744 
00745   MPI_Allgather(meshmin, 3, MPI_INT, meshmin_list, 3, MPI_INT, MPI_COMM_WORLD);
00746   MPI_Allgather(meshmax, 3, MPI_INT, meshmax_list, 3, MPI_INT, MPI_COMM_WORLD);
00747 
00748   dimx = meshmax[0] - meshmin[0] + 2;
00749   dimy = meshmax[1] - meshmin[1] + 2;
00750   dimz = meshmax[2] - meshmin[2] + 2;
00751 
00752   <a class="code" href="proto_8h.html#a125">pm_init_periodic_allocate</a>((dimx + 4) * (dimy + 4) * (dimz + 4));
00753 
00754   <span class="keywordflow">for</span>(i = 0; i &lt; dimx * dimy * dimz; i++)
00755     workspace[i] = 0;
00756 
00757   <span class="keywordflow">for</span>(i = 0; i &lt; NumPart; i++)
00758     {
00759       slab_x = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0];
00760       <span class="keywordflow">if</span>(slab_x &gt;= PMGRID)
00761         slab_x = PMGRID - 1;
00762       dx = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] - slab_x;
00763       slab_x -= meshmin[0];
00764       slab_xx = slab_x + 1;
00765 
00766       slab_y = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1];
00767       <span class="keywordflow">if</span>(slab_y &gt;= PMGRID)
00768         slab_y = PMGRID - 1;
00769       dy = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] - slab_y;
00770       slab_y -= meshmin[1];
00771       slab_yy = slab_y + 1;
00772 
00773       slab_z = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2];
00774       <span class="keywordflow">if</span>(slab_z &gt;= PMGRID)
00775         slab_z = PMGRID - 1;
00776       dz = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] - slab_z;
00777       slab_z -= meshmin[2];
00778       slab_zz = slab_z + 1;
00779 
00780       workspace[(slab_x * dimy + slab_y) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * (1.0 - dy) * (1.0 - dz);
00781       workspace[(slab_x * dimy + slab_yy) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * dy * (1.0 - dz);
00782       workspace[(slab_x * dimy + slab_y) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * (1.0 - dy) * dz;
00783       workspace[(slab_x * dimy + slab_yy) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (1.0 - dx) * dy * dz;
00784 
00785       workspace[(slab_xx * dimy + slab_y) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * (1.0 - dy) * (1.0 - dz);
00786       workspace[(slab_xx * dimy + slab_yy) * dimz + slab_z] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * dy * (1.0 - dz);
00787       workspace[(slab_xx * dimy + slab_y) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * (1.0 - dy) * dz;
00788       workspace[(slab_xx * dimy + slab_yy) * dimz + slab_zz] += <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o1">Mass</a> * (dx) * dy * dz;
00789     }
00790 
00791 
00792   <span class="keywordflow">for</span>(i = 0; i &lt; fftsize; i++)  <span class="comment">/* clear local density field */</span>
00793     rhogrid[i] = 0;
00794 
00795   <span class="keywordflow">for</span>(level = 0; level &lt; (1 &lt;&lt; PTask); level++) <span class="comment">/* note: for level=0, target is the same task */</span>
00796     {
00797       sendTask = ThisTask;
00798       recvTask = <a class="code" href="allvars_8c.html#a0">ThisTask</a> ^ level;
00799       <span class="keywordflow">if</span>(recvTask &lt; NTask)
00800         {
00801           <span class="comment">/* check how much we have to send */</span>
00802           sendmin = 2 * PMGRID;
00803           sendmax = -1;
00804           <span class="keywordflow">for</span>(slab_x = meshmin[0]; slab_x &lt; meshmax[0] + 2; slab_x++)
00805             <span class="keywordflow">if</span>(slab_to_task[slab_x % PMGRID] == recvTask)
00806               {
00807                 <span class="keywordflow">if</span>(slab_x &lt; sendmin)
00808                   sendmin = slab_x;
00809                 <span class="keywordflow">if</span>(slab_x &gt; sendmax)
00810                   sendmax = slab_x;
00811               }
00812           <span class="keywordflow">if</span>(sendmax == -1)
00813             sendmin = 0;
00814 
00815           <span class="comment">/* check how much we have to receive */</span>
00816           recvmin = 2 * PMGRID;
00817           recvmax = -1;
00818           <span class="keywordflow">for</span>(slab_x = meshmin_list[3 * recvTask]; slab_x &lt; meshmax_list[3 * recvTask] + 2; slab_x++)
00819             <span class="keywordflow">if</span>(slab_to_task[slab_x % PMGRID] == sendTask)
00820               {
00821                 <span class="keywordflow">if</span>(slab_x &lt; recvmin)
00822                   recvmin = slab_x;
00823                 <span class="keywordflow">if</span>(slab_x &gt; recvmax)
00824                   recvmax = slab_x;
00825               }
00826           <span class="keywordflow">if</span>(recvmax == -1)
00827             recvmin = 0;
00828 
00829 
00830           <span class="keywordflow">if</span>((recvmax - recvmin) &gt;= 0 || (sendmax - sendmin) &gt;= 0)      <span class="comment">/* ok, we have a contribution to the slab */</span>
00831             {
00832               recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * recvTask + 0] + 2;
00833               recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * recvTask + 1] + 2;
00834               recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * recvTask + 2] + 2;
00835 
00836               <span class="keywordflow">if</span>(level &gt; 0)
00837                 {
00838                   MPI_Sendrecv(workspace + (sendmin - meshmin[0]) * dimy * dimz,
00839                                (sendmax - sendmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real), MPI_BYTE, recvTask,
00840                                <a class="code" href="tags_8h.html#a17">TAG_PERIODIC_C</a>, forcegrid,
00841                                (recvmax - recvmin + 1) * recv_dimy * recv_dimz * <span class="keyword">sizeof</span>(fftw_real), MPI_BYTE,
00842                                recvTask, <a class="code" href="tags_8h.html#a17">TAG_PERIODIC_C</a>, MPI_COMM_WORLD, &amp;status);
00843                 }
00844               <span class="keywordflow">else</span>
00845                 {
00846                   memcpy(forcegrid, workspace + (sendmin - meshmin[0]) * dimy * dimz,
00847                          (sendmax - sendmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real));
00848                 }
00849 
00850               <span class="keywordflow">for</span>(slab_x = recvmin; slab_x &lt;= recvmax; slab_x++)
00851                 {
00852                   slab_xx = (slab_x % PMGRID) - first_slab_of_task[ThisTask];
00853 
00854                   <span class="keywordflow">if</span>(slab_xx &gt;= 0 &amp;&amp; slab_xx &lt; slabs_per_task[ThisTask])
00855                     {
00856                       <span class="keywordflow">for</span>(slab_y = meshmin_list[3 * recvTask + 1];
00857                           slab_y &lt;= meshmax_list[3 * recvTask + 1] + 1; slab_y++)
00858                         {
00859                           slab_yy = slab_y;
00860                           <span class="keywordflow">if</span>(slab_yy &gt;= PMGRID)
00861                             slab_yy -= PMGRID;
00862 
00863                           <span class="keywordflow">for</span>(slab_z = meshmin_list[3 * recvTask + 2];
00864                               slab_z &lt;= meshmax_list[3 * recvTask + 2] + 1; slab_z++)
00865                             {
00866                               slab_zz = slab_z;
00867                               <span class="keywordflow">if</span>(slab_zz &gt;= PMGRID)
00868                                 slab_zz -= PMGRID;
00869 
00870                               rhogrid[PMGRID * <a class="code" href="pm__periodic_8c.html#a0">PMGRID2</a> * slab_xx + <a class="code" href="pm__periodic_8c.html#a0">PMGRID2</a> * slab_yy + slab_zz] +=
00871                                 forcegrid[((slab_x - recvmin) * recv_dimy +
00872                                            (slab_y - meshmin_list[3 * recvTask + 1])) * recv_dimz +
00873                                           (slab_z - meshmin_list[3 * recvTask + 2])];
00874                             }
00875                         }
00876                     }
00877                 }
00878             }
00879         }
00880     }
00881 
00882 
00883 
00884   <span class="comment">/* Do the FFT of the density field */</span>
00885 
00886   rfftwnd_mpi(fft_forward_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);
00887 
00888   <span class="comment">/* multiply with Green's function for the potential */</span>
00889 
00890   <span class="keywordflow">for</span>(y = slabstart_y; y &lt; slabstart_y + nslab_y; y++)
00891     <span class="keywordflow">for</span>(x = 0; x &lt; PMGRID; x++)
00892       <span class="keywordflow">for</span>(z = 0; z &lt; PMGRID / 2 + 1; z++)
00893         {
00894           <span class="keywordflow">if</span>(x &gt; PMGRID / 2)
00895             kx = x - PMGRID;
00896           <span class="keywordflow">else</span>
00897             kx = x;
00898           <span class="keywordflow">if</span>(y &gt; PMGRID / 2)
00899             ky = y - PMGRID;
00900           <span class="keywordflow">else</span>
00901             ky = y;
00902           <span class="keywordflow">if</span>(z &gt; PMGRID / 2)
00903             kz = z - PMGRID;
00904           <span class="keywordflow">else</span>
00905             kz = z;
00906 
00907           k2 = kx * kx + ky * ky + kz * kz;
00908 
00909           <span class="keywordflow">if</span>(k2 &gt; 0)
00910             {
00911               smth = -exp(-k2 * asmth2) / k2 * fac;
00912               <span class="comment">/* do deconvolution */</span>
00913               fx = fy = fz = 1;
00914               <span class="keywordflow">if</span>(kx != 0)
00915                 {
00916                   fx = (M_PI * kx) / PMGRID;
00917                   fx = sin(fx) / fx;
00918                 }
00919               <span class="keywordflow">if</span>(ky != 0)
00920                 {
00921                   fy = (M_PI * ky) / PMGRID;
00922                   fy = sin(fy) / fy;
00923                 }
00924               <span class="keywordflow">if</span>(kz != 0)
00925                 {
00926                   fz = (M_PI * kz) / PMGRID;
00927                   fz = sin(fz) / fz;
00928                 }
00929               ff = 1 / (fx * fy * fz);
00930               smth *= ff * ff * ff * ff;
00931               <span class="comment">/* end deconvolution */</span>
00932 
00933               ip = PMGRID * (PMGRID / 2 + 1) * (y - slabstart_y) + (PMGRID / 2 + 1) * x + z;
00934               fft_of_rhogrid[ip].re *= smth;
00935               fft_of_rhogrid[ip].im *= smth;
00936             }
00937         }
00938 
00939   <span class="keywordflow">if</span>(slabstart_y == 0)
00940     fft_of_rhogrid[0].re = fft_of_rhogrid[0].im = 0.0;
00941 
00942   <span class="comment">/* Do the FFT to get the potential */</span>
00943 
00944   rfftwnd_mpi(fft_inverse_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);
00945 
00946   <span class="comment">/* note: "rhogrid" now contains the potential */</span>
00947 
00948 
00949 
00950   dimx = meshmax[0] - meshmin[0] + 6;
00951   dimy = meshmax[1] - meshmin[1] + 6;
00952   dimz = meshmax[2] - meshmin[2] + 6;
00953 
00954   <span class="keywordflow">for</span>(level = 0; level &lt; (1 &lt;&lt; PTask); level++) <span class="comment">/* note: for level=0, target is the same task */</span>
00955     {
00956       sendTask = ThisTask;
00957       recvTask = <a class="code" href="allvars_8c.html#a0">ThisTask</a> ^ level;
00958 
00959       <span class="keywordflow">if</span>(recvTask &lt; NTask)
00960         {
00961 
00962           <span class="comment">/* check how much we have to send */</span>
00963           sendmin = 2 * PMGRID;
00964           sendmax = -PMGRID;
00965           <span class="keywordflow">for</span>(slab_x = meshmin_list[3 * recvTask] - 2; slab_x &lt; meshmax_list[3 * recvTask] + 4; slab_x++)
00966             <span class="keywordflow">if</span>(slab_to_task[(slab_x + PMGRID) % PMGRID] == sendTask)
00967               {
00968                 <span class="keywordflow">if</span>(slab_x &lt; sendmin)
00969                   sendmin = slab_x;
00970                 <span class="keywordflow">if</span>(slab_x &gt; sendmax)
00971                   sendmax = slab_x;
00972               }
00973           <span class="keywordflow">if</span>(sendmax == -PMGRID)
00974             sendmin = sendmax + 1;
00975 
00976 
00977           <span class="comment">/* check how much we have to receive */</span>
00978           recvmin = 2 * PMGRID;
00979           recvmax = -PMGRID;
00980           <span class="keywordflow">for</span>(slab_x = meshmin[0] - 2; slab_x &lt; meshmax[0] + 4; slab_x++)
00981             <span class="keywordflow">if</span>(slab_to_task[(slab_x + PMGRID) % PMGRID] == recvTask)
00982               {
00983                 <span class="keywordflow">if</span>(slab_x &lt; recvmin)
00984                   recvmin = slab_x;
00985                 <span class="keywordflow">if</span>(slab_x &gt; recvmax)
00986                   recvmax = slab_x;
00987               }
00988           <span class="keywordflow">if</span>(recvmax == -PMGRID)
00989             recvmin = recvmax + 1;
00990 
00991           <span class="keywordflow">if</span>((recvmax - recvmin) &gt;= 0 || (sendmax - sendmin) &gt;= 0)      <span class="comment">/* ok, we have a contribution to the slab */</span>
00992             {
00993               recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * recvTask + 0] + 6;
00994               recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * recvTask + 1] + 6;
00995               recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * recvTask + 2] + 6;
00996 
00997               ncont = 1;
00998               cont_sendmin[0] = sendmin;
00999               cont_sendmax[0] = sendmax;
01000               cont_sendmin[1] = sendmax + 1;
01001               cont_sendmax[1] = sendmax;
01002 
01003               cont_recvmin[0] = recvmin;
01004               cont_recvmax[0] = recvmax;
01005               cont_recvmin[1] = recvmax + 1;
01006               cont_recvmax[1] = recvmax;
01007 
01008               <span class="keywordflow">for</span>(slab_x = sendmin; slab_x &lt;= sendmax; slab_x++)
01009                 {
01010                   <span class="keywordflow">if</span>(slab_to_task[(slab_x + PMGRID) % PMGRID] != ThisTask)
01011                     {
01012                       <span class="comment">/* non-contiguous */</span>
01013                       cont_sendmax[0] = slab_x - 1;
01014                       <span class="keywordflow">while</span>(slab_to_task[(slab_x + PMGRID) % PMGRID] != ThisTask)
01015                         slab_x++;
01016                       cont_sendmin[1] = slab_x;
01017                       ncont++;
01018                     }
01019                 }
01020 
01021               <span class="keywordflow">for</span>(slab_x = recvmin; slab_x &lt;= recvmax; slab_x++)
01022                 {
01023                   <span class="keywordflow">if</span>(slab_to_task[(slab_x + PMGRID) % PMGRID] != recvTask)
01024                     {
01025                       <span class="comment">/* non-contiguous */</span>
01026                       cont_recvmax[0] = slab_x - 1;
01027                       <span class="keywordflow">while</span>(slab_to_task[(slab_x + PMGRID) % PMGRID] != recvTask)
01028                         slab_x++;
01029                       cont_recvmin[1] = slab_x;
01030                       <span class="keywordflow">if</span>(ncont == 1)
01031                         ncont++;
01032                     }
01033                 }
01034 
01035 
01036               <span class="keywordflow">for</span>(rep = 0; rep &lt; ncont; rep++)
01037                 {
01038                   sendmin = cont_sendmin[rep];
01039                   sendmax = cont_sendmax[rep];
01040                   recvmin = cont_recvmin[rep];
01041                   recvmax = cont_recvmax[rep];
01042 
01043                   <span class="comment">/* prepare what we want to send */</span>
01044                   <span class="keywordflow">if</span>(sendmax - sendmin &gt;= 0)
01045                     {
01046                       <span class="keywordflow">for</span>(slab_x = sendmin; slab_x &lt;= sendmax; slab_x++)
01047                         {
01048                           slab_xx = ((slab_x + PMGRID) % PMGRID) - first_slab_of_task[ThisTask];
01049 
01050                           <span class="keywordflow">for</span>(slab_y = meshmin_list[3 * recvTask + 1] - 2;
01051                               slab_y &lt; meshmax_list[3 * recvTask + 1] + 4; slab_y++)
01052                             {
01053                               slab_yy = (slab_y + PMGRID) % PMGRID;
01054 
01055                               <span class="keywordflow">for</span>(slab_z = meshmin_list[3 * recvTask + 2] - 2;
01056                                   slab_z &lt;= meshmax_list[3 * recvTask + 2] + 4; slab_z++)
01057                                 {
01058                                   slab_zz = (slab_z + PMGRID) % PMGRID;
01059 
01060                                   forcegrid[((slab_x - sendmin) * recv_dimy +
01061                                              (slab_y - (meshmin_list[3 * recvTask + 1] - 2))) * recv_dimz +
01062                                             slab_z - (meshmin_list[3 * recvTask + 2] - 2)] =
01063                                     rhogrid[PMGRID * <a class="code" href="pm__periodic_8c.html#a0">PMGRID2</a> * slab_xx + <a class="code" href="pm__periodic_8c.html#a0">PMGRID2</a> * slab_yy + slab_zz];
01064                                 }
01065                             }
01066                         }
01067                     }
01068 
01069                   <span class="keywordflow">if</span>(level &gt; 0)
01070                     {
01071                       MPI_Sendrecv(forcegrid,
01072                                    (sendmax - sendmin + 1) * recv_dimy * recv_dimz * <span class="keyword">sizeof</span>(fftw_real),
01073                                    MPI_BYTE, recvTask, <a class="code" href="tags_8h.html#a18">TAG_PERIODIC_D</a>,
01074                                    workspace + (recvmin - (meshmin[0] - 2)) * dimy * dimz,
01075                                    (recvmax - recvmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real), MPI_BYTE,
01076                                    recvTask, <a class="code" href="tags_8h.html#a18">TAG_PERIODIC_D</a>, MPI_COMM_WORLD, &amp;status);
01077                     }
01078                   <span class="keywordflow">else</span>
01079                     {
01080                       memcpy(workspace + (recvmin - (meshmin[0] - 2)) * dimy * dimz,
01081                              forcegrid, (recvmax - recvmin + 1) * dimy * dimz * <span class="keyword">sizeof</span>(fftw_real));
01082                     }
01083                 }
01084             }
01085         }
01086     }
01087 
01088 
01089   dimx = meshmax[0] - meshmin[0] + 2;
01090   dimy = meshmax[1] - meshmin[1] + 2;
01091   dimz = meshmax[2] - meshmin[2] + 2;
01092 
01093   recv_dimx = meshmax[0] - meshmin[0] + 6;
01094   recv_dimy = meshmax[1] - meshmin[1] + 6;
01095   recv_dimz = meshmax[2] - meshmin[2] + 6;
01096 
01097 
01098 
01099   <span class="keywordflow">for</span>(x = 0; x &lt; meshmax[0] - meshmin[0] + 2; x++)
01100     <span class="keywordflow">for</span>(y = 0; y &lt; meshmax[1] - meshmin[1] + 2; y++)
01101       <span class="keywordflow">for</span>(z = 0; z &lt; meshmax[2] - meshmin[2] + 2; z++)
01102         {
01103           forcegrid[(x * dimy + y) * dimz + z] =
01104             workspace[((x + 2) * recv_dimy + (y + 2)) * recv_dimz + (z + 2)];
01105         }
01106 
01107 
01108   <span class="comment">/* read out the potential */</span>
01109 
01110   <span class="keywordflow">for</span>(i = 0; i &lt; NumPart; i++)
01111     {
01112       slab_x = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0];
01113       <span class="keywordflow">if</span>(slab_x &gt;= PMGRID)
01114         slab_x = PMGRID - 1;
01115       dx = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[0] - slab_x;
01116       slab_x -= meshmin[0];
01117       slab_xx = slab_x + 1;
01118 
01119       slab_y = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1];
01120       <span class="keywordflow">if</span>(slab_y &gt;= PMGRID)
01121         slab_y = PMGRID - 1;
01122       dy = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[1] - slab_y;
01123       slab_y -= meshmin[1];
01124       slab_yy = slab_y + 1;
01125 
01126       slab_z = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2];
01127       <span class="keywordflow">if</span>(slab_z &gt;= PMGRID)
01128         slab_z = PMGRID - 1;
01129       dz = to_slab_fac * <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o0">Pos</a>[2] - slab_z;
01130       slab_z -= meshmin[2];
01131       slab_zz = slab_z + 1;
01132 
01133       <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o6">Potential</a> +=
01134         forcegrid[(slab_x * dimy + slab_y) * dimz + slab_z] * (1.0 - dx) * (1.0 - dy) * (1.0 - dz);
01135       <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o6">Potential</a> += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_z] * (1.0 - dx) * dy * (1.0 - dz);
01136       <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o6">Potential</a> += forcegrid[(slab_x * dimy + slab_y) * dimz + slab_zz] * (1.0 - dx) * (1.0 - dy) * dz;
01137       <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o6">Potential</a> += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_zz] * (1.0 - dx) * dy * dz;
01138 
01139       <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o6">Potential</a> += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_z] * (dx) * (1.0 - dy) * (1.0 - dz);
01140       <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o6">Potential</a> += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_z] * (dx) * dy * (1.0 - dz);
01141       <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o6">Potential</a> += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_zz] * (dx) * (1.0 - dy) * dz;
01142       <a class="code" href="allvars_8c.html#a51">P</a>[i].<a class="code" href="structparticle__data.html#o6">Potential</a> += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_zz] * (dx) * dy * dz;
01143     }
01144 
01145   <a class="code" href="pm__periodic_8c.html#a22">pm_init_periodic_free</a>();
01146   <a class="code" href="proto_8h.html#a57">force_treeallocate</a>(<a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o15">TreeAllocFactor</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o2">MaxPart</a>, <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o2">MaxPart</a>);
01147 
01148   <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o23">NumForcesSinceLastDomainDecomp</a> = 1 + <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o0">TotNumPart</a> * <a class="code" href="allvars_8c.html#a50">All</a>.<a class="code" href="structglobal__data__all__processes.html#o96">TreeDomainUpdateFrequency</a>;
01149 
01150   <span class="keywordflow">if</span>(<a class="code" href="allvars_8c.html#a0">ThisTask</a> == 0)
01151     {
01152       printf(<span class="stringliteral">"done PM-Potential.\n"</span>);
01153       fflush(stdout);
01154     }
01155 }
01156 
01157 <span class="preprocessor">#endif</span>
01158 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Apr 22 15:29:41 2006 for GADGET-2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
